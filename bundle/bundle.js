!function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=10)}([function(e,t,n){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const o=r(n(12)),i=r(n(2)),a=(()=>{const e=__dirname,t=i.default.resolve(e,".."),n=i.default.resolve(t,"logs");return i.default.resolve(n,`${Date.now()}`)})(),s=o.default.createLogger({level:"verbose",defaultMeta:{service:"user-service"},format:o.default.format.combine(o.default.format.timestamp(),o.default.format.json()),transports:[new o.default.transports.File({filename:"error.log",level:"error",dirname:a}),new o.default.transports.File({filename:"combined.log",dirname:a})]});const l={error:function(e,t){s.error(`${e} - ${t}`)},info:function(e,t){s.info(`${e} - ${t}`)},verbose:function(e,t){s.verbose(`${e} - ${t}`)}};t.log=l},function(e,t){e.exports=require("fs-extra")},function(e,t){e.exports=require("path")},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.assertNever=function(e){throw new Error("Unexpected object: "+e)}},function(e,t,n){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const o=r(n(5)),i=r(n(1)),a=r(n(2)),s=n(0);function l(e,t){return a.default.resolve(e,t)}function c(e){try{return o.default.lstatSync(e).isDirectory()}catch(t){s.log.error("FS:isDirectory",`${e}::${t}`)}}function f(e){try{return o.default.lstatSync(e).isFile()}catch(t){s.log.error("FS:isRegularFile",`${e}::${t}`)}}function u(e){try{return o.default.lstatSync(e).isSymbolicLink()}catch(t){s.log.error("FS:isSymlink",`${e}::${t}`)}}function d(e){const t=a.default.parse(e).dir;i.default.ensureDirSync(t)}t.getDirectoryFromFilePath=function(e){return a.default.basename(e)},t.getFileNameExtension=function(e){return a.default.extname(e)},t.resolvePath=l,t.isDirectory=c,t.isRegularFile=f,t.isSymlink=u,t.getRelativePath=function(e,t){return a.default.relative(t,e)},t.writeFile=function(e,t,n,r){try{const l=a.default.basename(t),c=a.default.parse(t).dir,f=a.default.resolve(e,c);o.default.existsSync(f)||i.default.ensureDirSync(f);const u=a.default.resolve(f,r?`${l}.${r}`:l);o.default.existsSync(u)&&s.log.error("FS:writeFile",`Trying to write to file which already exists: ${u}`),o.default.writeFileSync(u,n)}catch(n){s.log.error("FS:writeFile",`File Writing Failed::${e}::${t}::${n}`)}},t.traverseDirectory=function e(t,n,r,i,d=[],p=!0){s.log.verbose("traverseDirectory",`Entering ${t}\\${n}`);const h=l(t,n);if(f(h))r(h,t);else if(c(h)){o.default.readdirSync(h).forEach(o=>{const l=a.default.resolve(h,o),c=n+"\\"+o;d.includes(c.startsWith(".\\")?c.substr(2):c)?s.log.verbose("traverseDirectory",`Ignoring ${t}\\${c} as it's blacklisted.`):(i(l,t),p&&e(t,c,r,i,d,p))})}else u(h)&&s.log.error("FS:traverseDirectory",`We currently dont support symlinks: ${h}`)},t.lookUpRelativePath=function(e,t,n,r){const i=a.default.resolve(e,t);o.default.existsSync(i)?n(i):r(i)},t.initDirectory=function(e){i.default.removeSync(e),i.default.existsSync(e)&&s.log.error("FS:initDirectory",`Output directory can't be nuked !! (${e})`),i.default.ensureDirSync(e)},t.copyFile=function(e,t){d(t),i.default.copyFileSync(e,t)},t.copyFileOverwrite=function(e,t){d(t),o.default.existsSync(t)||s.log.error("FS:copyFileOverwrite",`Trying to overwrite file but the target doesn't already exist (${t})!`),i.default.copyFileSync(e,t)},t.copyFile2=function(e,t,n){const r=a.default.parse(t).dir,l=a.default.resolve(e,r);o.default.existsSync(l)||i.default.ensureDirSync(l);const c=a.default.resolve(e,t);o.default.existsSync(c)&&s.log.error("FS:copyFile2",`Trying to copy binary file but it already exists (${n})!`),i.default.copyFileSync(n,c)},t.copyFile2Overwrite=function(e,t,n){const r=a.default.parse(t).dir,l=a.default.resolve(e,r);o.default.existsSync(l)||i.default.ensureDirSync(l);const c=a.default.resolve(e,t);o.default.existsSync(c)||s.log.error("FS:copyFile2Overwrite",`Trying to overwrite file but the target doesn't already exist (${t})!`),i.default.copyFileSync(n,c)}},function(e,t){e.exports=require("fs")},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(7),o=n(0),i=n(13),a=n(14),s=n(15);t.diffFiles=function(e,t,n,i,a,s){const l=[e,n,"-u"];t&&l.push("--unidirectional-new-file");const c=r.spawn(s,l);c.stdout.on("data",e=>{i(e)}),c.stderr.on("data",e=>{a(`${s} ${l} failed with message: ${e}`)}),c.on("close",e=>{o.log.verbose("Patch",`git child process exited with code ${e}`)})},t.applyPatchTool=function(e,t,n,i,a,s){const l=["-i",t,e,"-s"];s&&l.push("-R");const c=r.spawn(a,l);o.log.info("Patch","Calling C:\\Program Files\\Git\\usr\\bin\\patch.exe "+l.toString()),c.on("message",e=>{n(`Patch message: ${e}`)}),c.stdout.on("data",e=>{n(`Patch output: ${e}`)}),c.stderr.on("data",e=>{i(`${a} ${l} failed with message: ${e}`)}),c.on("close",e=>{o.log.info("Patch",`patch child process exited with code ${e}`)})},t.applyPatchEmbedded=function({patchFilePath:e,targetFilePathOverride:t,reverse:n}){const r=s.readPatch({patchFilePath:e});try{i.executeEffects(n?a.reversePatch(r):r,t,{dryRun:!1})}catch(e){try{i.executeEffects(n?r:a.reversePatch(r),t,{dryRun:!0})}catch(e){return!1}}return!0}},function(e,t){e.exports=require("child_process")},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(3);t.parseHunkHeaderLine=e=>{const t=e.trim().match(/^@@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))? @@.*/);if(!t)throw new Error(`Bad header line: '${e}'`);return{original:{start:Math.max(Number(t[1]),1),length:Number(t[3]||1)},patched:{start:Math.max(Number(t[4]),1),length:Number(t[6]||1)}}},t.NON_EXECUTABLE_FILE_MODE=420,t.EXECUTABLE_FILE_MODE=493;const o={"@":"header","-":"deletion","+":"insertion"," ":"context","\\":"pragma",undefined:"context"};function i(e,{supportLegacyDiffs:n}){const i=[];let a={diffLineFromPath:null,diffLineToPath:null,oldMode:null,newMode:null,deletedFileMode:null,newFileMode:null,renameFrom:null,renameTo:null,beforeHash:null,afterHash:null,fromPath:null,toPath:null,hunks:null},s="parsing header",c=null,f=null;function u(){c&&(f&&(c.parts.push(f),f=null),a.hunks.push(c),c=null)}function d(){u(),i.push(a),a={diffLineFromPath:null,diffLineToPath:null,oldMode:null,newMode:null,deletedFileMode:null,newFileMode:null,renameFrom:null,renameTo:null,beforeHash:null,afterHash:null,fromPath:null,toPath:null,hunks:null}}for(let i=0;i<e.length;i++){const l=e[i];if("parsing header"===s)if(l.startsWith("@@"))s="parsing hunks",a.hunks=[],i--;else if(l.startsWith("diff --git ")){a&&a.diffLineFromPath&&d();const e=l.match(/^diff --git a\/(.*?) b\/(.*?)\s*$/);if(!e)throw new Error("Bad diff line: "+l);a.diffLineFromPath=e[1],a.diffLineToPath=e[2]}else if(l.startsWith("old mode "))a.oldMode=l.slice("old mode ".length).trim();else if(l.startsWith("new mode "))a.newMode=l.slice("new mode ".length).trim();else if(l.startsWith("deleted file mode "))a.deletedFileMode=l.slice("deleted file mode ".length).trim();else if(l.startsWith("new file mode "))a.newFileMode=l.slice("new file mode ".length).trim();else if(l.startsWith("rename from "))a.renameFrom=l.slice("rename from ".length).trim();else if(l.startsWith("rename to "))a.renameTo=l.slice("rename to ".length).trim();else if(l.startsWith("index ")){const e=l.match(/(\w+)\.\.(\w+)/);if(!e)continue;a.beforeHash=e[1],a.afterHash=e[2]}else l.startsWith("--- ")?a.fromPath=l.slice("--- a/".length).trim():l.startsWith("+++ ")&&(a.toPath=l.slice("+++ b/".length).trim());else{if(n&&l.startsWith("--- a/")){s="parsing header",d(),i--;continue}const e=o[l[0]]||null;switch(e){case"header":u(),p=l,c={header:t.parseHunkHeaderLine(p),parts:[]};break;case null:s="parsing header",d(),i--;break;case"pragma":if(!l.startsWith("\\ No newline at end of file"))throw new Error("Unrecognized pragma in patch file: "+l);if(!f)throw new Error("Bad parser state: No newline at EOF pragma encountered without context");f.noNewlineAtEndOfFile=!0;break;case"insertion":case"deletion":case"context":if(!c)throw new Error("Bad parser state: Hunk lines encountered before hunk header");f&&f.type!==e&&(c.parts.push(f),f=null),f||(f={type:e,lines:[],noNewlineAtEndOfFile:!1}),f.lines.push(l.slice(1));break;default:r.assertNever(e)}}}var p;d();for(const{hunks:e}of i)if(e)for(const t of e)l(t);return i}function a(e){const t=[];for(const n of e){const{diffLineFromPath:e,diffLineToPath:o,oldMode:i,newMode:a,deletedFileMode:l,newFileMode:c,renameFrom:f,renameTo:u,beforeHash:d,afterHash:p,fromPath:h,toPath:g,hunks:y}=n,m=f?"rename":l?"file deletion":c?"file creation":y&&y.length>0?"patch":"mode change";let b=null;switch(m){case"rename":if(!f||!u)throw new Error("Bad parser state: rename from & to not given");t.push({type:"rename",fromPath:f,toPath:u}),b=u;break;case"file deletion":{const n=e||h;if(!n)throw new Error("Bad parse state: no path given for file deletion");t.push({type:"file deletion",hunk:y&&y[0]||null,path:n,mode:s(l),hash:d});break}case"file creation":{const e=o||g;if(!e)throw new Error("Bad parse state: no path given for file creation");t.push({type:"file creation",hunk:y&&y[0]||null,path:e,mode:s(c),hash:p});break}case"patch":case"mode change":b=g||o;break;default:r.assertNever(m)}b&&i&&a&&i!==a&&t.push({type:"mode change",path:b,oldMode:s(i),newMode:s(a)}),b&&y&&y.length&&t.push({type:"patch",path:b,hunks:y,beforeHash:d,afterHash:p})}return t}function s(e){const n=511&parseInt(e,8);if(n!==t.NON_EXECUTABLE_FILE_MODE&&n!==t.EXECUTABLE_FILE_MODE)throw new Error("Unexpected file mode string: "+e);return n}function l(e){let t=0,n=0;for(const{type:o,lines:i}of e.parts)switch(o){case"context":n+=i.length,t+=i.length;break;case"deletion":t+=i.length;break;case"insertion":n+=i.length;break;default:r.assertNever(o)}if(t!==e.header.original.length||n!==e.header.patched.length)throw new Error("hunk header integrity check failed")}t.interpretParsedPatchFile=a,t.parsePatchFile=function(e){const t=e.split(/\n/g);""===t[t.length-1]&&t.pop();try{return a(i(t,{supportLegacyDiffs:!1}))}catch(e){if(e instanceof Error&&"hunk header integrity check failed"===e.message)return a(i(t,{supportLegacyDiffs:!0}));throw e}},t.verifyHunkIntegrity=l},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(16);t.isFileText=function(e){return r.isTextSync(e)},t.isFileBinary=function(e){return r.isBinarySync(e)}},function(e,t,n){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const o=r(n(11)),i=r(n(20));n(21).initCli(o.default,i.default)},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(4),o=n(6),i=n(0),a=n(9),s=n(17),l=n(19);t.default=(e,t,n)=>{i.log.info("diffRepos",`dirtyRepoAbsPath: ${e}`),i.log.info("diffRepos",`baseRepoAbsPath: ${t}`),i.log.info("diffRepos",`options.patchName: ${n.patchName}`),i.log.info("diffRepos",`options.whitelistDirs: ${n.whitelistDirs}`),i.log.info("diffRepos",`options.blacklistDirs: ${n.blacklistDirs}`),i.log.info("diffRepos",`options.blacklistExts: ${n.blacklistExts}`),i.log.info("diffRepos",`options.gitExecutable: ${n.gitExecutable}`),i.log.info("diffRepos",`options.cleanupRepos: ${n.cleanupRepos}`),i.log.info("diffRepos",`options.diffExecutable: ${n.diffExecutable}`),i.log.info("diffRepos",`options.cleanupExistingPatches: ${n.cleanupExistingPatches}`);const c=r.resolvePath(e,n.patchName);r.initDirectory(c),n.cleanupRepos&&(l.cleanRepoSync(n.baseFork,n.gitExecutable),l.cleanRepoSync(n.dirtyFork,n.gitExecutable));const f=l=>{const f=r.getRelativePath(l,e),u=r.getFileNameExtension(l);if(n.blacklistExts.includes(u))return void i.log.info("diffRNFork","Ignoring {dirtyRepoFileAbsPath} based on file name extension.");r.lookUpRelativePath(t,f,e=>{const t=e=>{r.writeFile(c,f,`${e}`,"")},u=e=>{i.log.error("diffRNFork",e)},d=e=>{e?i.log.info("diffRNFork",`Skip copying identical binary files: ${f}`):r.copyFile2(c,f,l)},p=e=>{i.log.error("diffRNFork",`callbackOnBinaryFilesCompareError: ${e}`)};a.isFileBinary(l)?s.compareFiles(e,l,d,p):o.diffFiles(e,!1,l,t,u,n.diffExecutable)},e=>{const t=e=>{r.writeFile(c,f,`${e}`,"")},s=e=>{i.log.error("diffRNFork",e)};a.isFileBinary(l)?r.copyFile2(c,f,l):o.diffFiles(e,!0,l,t,s,n.diffExecutable)})},u=e=>{};0===n.whitelistDirs.length?r.traverseDirectory(e,".",f,u,n.blacklistDirs):n.whitelistDirs.forEach(t=>{n.blacklistDirs.includes(t.startsWith(".\\")?t.substr(2):t)?i.log.info("diffRNFork",`${t} is present in both whitelist as well as blacklist. Ignoring it.`):r.traverseDirectory(e,t,f,u,n.blacklistDirs)})}},function(e,t){e.exports=require("winston")},function(e,t,n){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const o=r(n(1)),i=n(2),a=n(3);function s(e){return(64&e)>0}t.executeEffects=(e,t,{dryRun:n})=>{e.forEach(e=>{switch(e.type){case"file deletion":if(n){if(!o.default.existsSync(e.path))throw new Error("Trying to delete file that doesn't exist: "+e.path)}else o.default.unlinkSync(e.path);break;case"rename":if(n){if(!o.default.existsSync(e.fromPath))throw new Error("Trying to move file that doesn't exist: "+e.fromPath)}else o.default.moveSync(e.fromPath,e.toPath);break;case"file creation":if(n){if(o.default.existsSync(e.path))throw new Error("Trying to create file that already exists: "+e.path)}else{const t=e.hunk?e.hunk.parts[0].lines.join("\n")+(e.hunk.parts[0].noNewlineAtEndOfFile?"":"\n"):"";o.default.ensureDirSync(i.dirname(e.path)),o.default.writeFileSync(e.path,t,{mode:e.mode})}break;case"patch":!function({hunks:e,path:t},n,{dryRun:r}){let s="",l=0;o.default.existsSync(n)&&(s=o.default.readFileSync(n).toString(),l=o.default.statSync(n).mode);const f=s.split(/\n/),u=[];for(const t of e){let r=0;for(;;){const o=c(t,f,r);if(o){u.push(o);break}if(r=r<0?-1*r:-1*r-1,Math.abs(r)>20)throw new Error(`Cant apply hunk ${e.indexOf(t)} for file ${n}`)}}if(r)return;let d=0;for(const e of u)for(const t of e)switch(t.type){case"splice":f.splice(t.index+d,t.numToDelete,...t.linesToInsert),d+=t.linesToInsert.length-t.numToDelete;break;case"pop":f.pop();break;case"push":f.push(t.line);break;default:a.assertNever(t)}o.default.ensureDirSync(i.dirname(n)),o.default.writeFileSync(n,f.join("\n"),{mode:l})}(e,t,{dryRun:n});break;case"mode change":const r=o.default.statSync(e.path).mode;(s(e.newMode)&&s(r)||!s(e.newMode)&&!s(r))&&n&&console.warn(`Mode change is not required for file ${e.path}`),o.default.chmodSync(e.path,e.newMode);break;default:a.assertNever(e)}})};const l=e=>e.replace(/\s+$/,"");function c(e,t,n){const r=[];let o=e.header.original.start-1+n;if(o<0)return null;if(t.length-o<e.header.original.length)return null;for(const n of e.parts)switch(n.type){case"deletion":case"context":for(const e of n.lines){const n=t[o];if(i=e,l(n)!==l(i))return null;o++}"deletion"===n.type&&(r.push({type:"splice",index:o-n.lines.length,numToDelete:n.lines.length,linesToInsert:[]}),n.noNewlineAtEndOfFile&&r.push({type:"push",line:""}));break;case"insertion":r.push({type:"splice",index:o,numToDelete:0,linesToInsert:n.lines}),n.noNewlineAtEndOfFile&&r.push({type:"pop"});break;default:a.assertNever(n.type)}var i;return r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(8),o=n(3);function i(e){const t={original:e.header.patched,patched:e.header.original},n=[];for(const t of e.parts)switch(t.type){case"context":n.push(t);break;case"deletion":n.push({type:"insertion",lines:t.lines,noNewlineAtEndOfFile:t.noNewlineAtEndOfFile});break;case"insertion":n.push({type:"deletion",lines:t.lines,noNewlineAtEndOfFile:t.noNewlineAtEndOfFile});break;default:o.assertNever(t.type)}for(let e=0;e<n.length-1;e++)if("insertion"===n[e].type&&"deletion"===n[e+1].type){const t=n[e];n[e]=n[e+1],n[e+1]=t,e+=1}const i={header:t,parts:n};return r.verifyHunkIntegrity(i),i}function a(e){switch(e.type){case"file creation":return{type:"file deletion",path:e.path,hash:e.hash,hunk:e.hunk&&i(e.hunk),mode:e.mode};case"file deletion":return{type:"file creation",path:e.path,hunk:e.hunk&&i(e.hunk),mode:e.mode,hash:e.hash};case"rename":return{type:"rename",fromPath:e.toPath,toPath:e.fromPath};case"patch":return{type:"patch",path:e.path,hunks:e.hunks.map(i),beforeHash:e.afterHash,afterHash:e.beforeHash};case"mode change":return{type:"mode change",path:e.path,newMode:e.oldMode,oldMode:e.newMode}}}t.reversePatch=e=>e.map(a).reverse()},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(1),o=n(8);t.readPatch=function({patchFilePath:e}){try{return o.parsePatchFile(r.readFileSync(e).toString())}catch(e){process.exit(1)}return[]}},function(e,t){e.exports=require("istextorbinary")},function(e,t,n){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const o=r(n(5)),i=r(n(18)),a=n(0);t.compareFiles=function(e,t,n,r){try{const r=i.default.createHash("md5"),s=o.default.createReadStream(e);s.on("data",e=>{r.update(e)}),s.on("end",()=>{const s=r.digest("base64"),l=i.default.createHash("md5"),c=o.default.createReadStream(t);c.on("data",e=>{l.update(e)}),c.on("end",()=>{const r=l.digest("base64");s===r?(a.log.info("compareFiles",`${e} AND ${t} are identical.  hashes: ${s} <==> ${r}`),n(!0)):(a.log.info("compareFiles",`${e} AND ${t} are different. hashes: ${s} <==> ${r}`),n(!1))})})}catch(e){r(`${e}`)}}},function(e,t){e.exports=require("crypto")},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(7),o=n(0);t.cleanRepoSync=function(e,t){const n=r.spawnSync(t,["clean","-fdx"],{cwd:e});n.error&&o.log.error("cleanRepoSync",`Failed with error : ${n.error}`)}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(4),o=n(0),i=n(6),a=n(9);function s(e,t,n,r,a){if(o.log.info("PatchRepo",`Applying ${t} on ${e} with options ${n}`),n.embeddedPatcher){i.applyPatchEmbedded({patchFilePath:t,targetFilePathOverride:e,reverse:n.reverse})||o.log.error("PatchRepo",`Applying ${t} on ${e} failed.`)}else i.applyPatchTool(e,t,e=>{o.log.info("PatchRepo",e)},e=>{o.log.error("PatchRepo",e)},n.patchExecutable,n.reverse)}t.default=(e,t,n)=>{o.log.info("patchRepo",`targetRepoAbsPath: ${e}`),o.log.info("patchRepo",`patchNames: ${t}`),o.log.info("patchRepo",`options.patchStore: ${n.patchStore}`),o.log.info("patchRepo",`enbeddedPatcher?: ${n.embeddedPatcher}`),o.log.info("patchRepo",`options.reverse: ${n.reverse}`),o.log.info("patchRepo",`options.patchExecutable: ${n.patchExecutable}`),o.log.info("patchRepo",`options.gitExecutable: ${n.gitExecutable}`),o.log.info("patchRepo",`options.cleanupRepos: ${n.cleanupRepos}`);const i=(t,i)=>{const l=r.getRelativePath(t,i);r.lookUpRelativePath(e,l,e=>{a.isFileBinary(t)?r.copyFileOverwrite(t,e):s(e,t,n)},e=>{o.log.error("PatchRepo",`File path with patches (${e}) not found in the target repository.`),a.isFileBinary(t)?r.copyFile(t,e):s(e,t,n)})},l=(e,t)=>{};t.forEach(e=>{const t=r.resolvePath(n.patchStore,e);r.traverseDirectory(t,".",i,l,[])})}},function(e,t,n){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const o=r(n(22));o.default.version("0.0.1"),t.initCli=function(e,t){function n(e,t){return e.split(",")}o.default.command("diff <dirtyRepo> <baseRepo>").description("Diff create ..").option("-pf, --patch-name <path>","Name of the patch folder. This new folder will be created under the dirty repo","patches").option("-de, --diff-executable <path>","Full path of the diff utility to be used for diffing between files. What we expect is a *x diff utility or compatible one: http://man7.org/linux/man-pages/man1/diff.1.html","C:\\Program Files\\Git\\usr\\bin\\diff.exe").option("-ge, --git-executable <path>","Full path of the git executable","C:\\Program Files\\Git\\bin\\git.exe").option("-cc, --cleanup-repos","Whether to clean up both the dirty and base repos. It will cleanup all non-tracked files. Essentially we run 'git clean -fdx'",!1).option("-cp, --cleanup-existing-patches","Cleanup the existing patches in the patches folder before starting a new diff run",!0).option("-bl, --blacklist-dirs <paths>","Paths in dirty repo to be excluded from the patch creation and application",n,[".ado",".appveyor",".circleci",".editorconfig",".eslintignore",".eslintrc",".flowconfig",".flowconfig.android",".flowconfig.macos",".git",".gitattributes",".github",".github.flowconfig.android",".gitignore",".nvmrc",".prettierrc","bots","Brewfile","danger","double-conversion","flow","flow-typed","Folly","follybuild","glog",".gradle",".idea","jest","jest-preset.js","jest.config.js","jsc","keystores","lib","metadata","office-android-patches","packages","React","React.podspec","ReactApple","runXcodeTests.sh","stubs","third-party-podspecs","v8-docker-build","website","yarn.lock","android","node_modules","ReactAndroid\\build","ReactAndroid\\packages","RNTester\\android\\app\\build","processor\\build","local.properties"]).option("-be, --blacklist-exts <exts>","File name extensions in dirty repo to be excluded from the patch creation and application",n,[".iml"]).option("-wl, --whitelist-dirs <paths>","Paths in dirty repo to be included in the patch creation and application",n,[]).action((t,n,r)=>{e(t,n,r)}),o.default.command("patch <targetRepo> [patchNames...]").option("-ps, --patch-store <path>","Full path of the directory where the patches can be found. Each patch is a subdirectory in this directory.","E:\\github\\office-android-patches\\patches-droid-office-grouped").option("-ep, --embedded-patcher","If true, use the embedded patching code written in Javascript. Currently, this code is taken from the source code the popular package : 'https://github.com/ds300/patch-package'. And adapted. Thanks !",!0).option("-pe, --patch-executable <path>","Full path of the patch utility to be used for patching. What we expect is a *x patch utility or compatible one: http://man7.org/linux/man-pages/man1/patch.1.html. Used only if embeddedPatcher is set to false.","C:\\Program Files\\Git\\usr\\bin\\patch.exe").option("-r, --reverse","Whether the patch is applied reverse",!1).option("-ge, --git-executable <path>","Full path of the git executable","C:\\Program Files\\Git\\bin\\git.exe").option("-cc, --cleanup-repos","Whether to clean up both the dirty and base repos. It will cleanup all non-tracked files. Essentially we run 'git clean -fdx'",!1).action((e,n,r)=>{t(e,n,r)}),o.default.parse(process.argv)}},function(e,t){e.exports=require("commander")}]);
//# sourceMappingURL=bundle.js.map
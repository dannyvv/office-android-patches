!function(e){var t={};function i(o){if(t[o])return t[o].exports;var r=t[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,i),r.l=!0,r.exports}i.m=e,i.c=t,i.d=function(e,t,o){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(i.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)i.d(o,r,function(t){return e[t]}.bind(null,r));return o},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=6)}([function(e,t,i){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=o(i(10)),n=r.default.createLogger({level:"verbose",defaultMeta:{service:"user-service"},format:r.default.format.combine(r.default.format.timestamp(),r.default.format.json()),transports:[new r.default.transports.File({filename:"error.log",level:"error",dirname:"logs"}),new r.default.transports.File({filename:"combined.log",dirname:`logs\\${Date.now()}`})]});const a={error:function(e,t){n.error(`${e} - ${t}`)},info:function(e,t){n.info(`${e} - ${t}`)},verbose:function(e,t){n.verbose(`${e} - ${t}`)}};t.log=a},function(e,t,i){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=o(i(2)),n=o(i(8)),a=o(i(9)),l=i(0);function s(e,t){return a.default.resolve(e,t)}function c(e){try{return r.default.lstatSync(e).isDirectory()}catch(t){l.log.error("FS:isDirectory",`${e}::${t}`)}}function u(e){try{return r.default.lstatSync(e).isFile()}catch(t){l.log.error("FS:isRegularFile",`${e}::${t}`)}}function f(e){try{return r.default.lstatSync(e).isSymbolicLink()}catch(t){l.log.error("FS:isSymlink",`${e}::${t}`)}}function p(e){const t=a.default.parse(e).dir;n.default.ensureDirSync(t)}t.getFileNameExtension=function(e){return a.default.extname(e)},t.resolvePath=s,t.isDirectory=c,t.isRegularFile=u,t.isSymlink=f,t.getRelativePath=function(e,t){return a.default.relative(t,e)},t.writeFile=function(e,t,i,o){try{const s=a.default.basename(t),c=a.default.parse(t).dir,u=a.default.resolve(e,c);r.default.existsSync(u)||n.default.ensureDirSync(u);const f=a.default.resolve(u,o?`${s}.${o}`:s);r.default.existsSync(f)&&l.log.error("FS:writeFile",`Trying to write to file which already exists: ${f}`),r.default.writeFileSync(f,i)}catch(i){l.log.error("FS:writeFile",`File Writing Failed::${e}::${t}::${i}`)}},t.traverseDirectory=function e(t,i,o,n,p=[],d=!0){l.log.verbose("traverseDirectory",`Entering ${t}\\${i}`);const h=s(t,i);if(u(h))o(h,t);else if(c(h)){r.default.readdirSync(h).forEach(r=>{const s=a.default.resolve(h,r),c=i+"\\"+r;p.includes(c.startsWith(".\\")?c.substr(2):c)?l.log.verbose("traverseDirectory",`Ignoring ${t}\\${c} as it's blacklisted.`):(n(s,t),d&&e(t,c,o,n,p,d))})}else f(h)&&l.log.error("FS:traverseDirectory",`We currently dont support symlinks: ${h}`)},t.lookUpRelativePath=function(e,t,i,o){const n=a.default.resolve(e,t);r.default.existsSync(n)?i(n):o(n)},t.initDirectory=function(e){n.default.removeSync(e),n.default.existsSync(e)&&l.log.error("FS:initDirectory",`Output directory can't be nuked !! (${e})`),n.default.ensureDirSync(e)},t.copyFile=function(e,t){p(t),n.default.copyFileSync(e,t)},t.copyFileOverwrite=function(e,t){p(t),r.default.existsSync(t)||l.log.error("FS:copyFileOverwrite",`Trying to overwrite file but the target doesn't already exist (${t})!`),n.default.copyFileSync(e,t)},t.copyFile2=function(e,t,i){const o=a.default.parse(t).dir,s=a.default.resolve(e,o);r.default.existsSync(s)||n.default.ensureDirSync(s);const c=a.default.resolve(e,t);r.default.existsSync(c)&&l.log.error("FS:copyFile2",`Trying to copy binary file but it already exists (${i})!`),n.default.copyFileSync(i,c)},t.copyFile2Overwrite=function(e,t,i){const o=a.default.parse(t).dir,s=a.default.resolve(e,o);r.default.existsSync(s)||n.default.ensureDirSync(s);const c=a.default.resolve(e,t);r.default.existsSync(c)||l.log.error("FS:copyFile2Overwrite",`Trying to overwrite file but the target doesn't already exist (${t})!`),n.default.copyFileSync(i,c)}},function(e,t){e.exports=require("fs")},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=i(4),r=i(0);t.diffFiles=function(e,t,i,n,a,l){const s=[e,i,"-u"];t&&s.push("--unidirectional-new-file");const c=o.spawn(l,s);c.stdout.on("data",e=>{n(e)}),c.stderr.on("data",e=>{a(`${l} ${s} failed with message: ${e}`)}),c.on("close",e=>{r.log.verbose("Patch",`git child process exited with code ${e}`)})},t.applyPatch=function(e,t,i,n,a,l){const s=["-i",t,e,"-s"];l&&s.push("-R");const c=o.spawn(a,s);r.log.info("Patch","Calling C:\\Program Files\\Git\\usr\\bin\\patch.exe "+s.toString()),c.on("message",e=>{i(`Patch message: ${e}`)}),c.stdout.on("data",e=>{i(`Patch output: ${e}`)}),c.stderr.on("data",e=>{n(`${a} ${s} failed with message: ${e}`)}),c.on("close",e=>{r.log.info("Patch",`patch child process exited with code ${e}`)})}},function(e,t){e.exports=require("child_process")},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=i(11);t.isFileText=function(e){return o.isTextSync(e)},t.isFileBinary=function(e){return o.isBinarySync(e)}},function(e,t,i){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=o(i(7)),n=o(i(15));i(16).initCli(r.default,n.default)},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=i(1),r=i(3),n=i(0),a=i(5),l=i(12),s=i(14);t.default=(e,t,i)=>{n.log.info("diffRepos",`dirtyRepoAbsPath: ${e}`),n.log.info("diffRepos",`baseRepoAbsPath: ${t}`),n.log.info("diffRepos",`options.patchName: ${i.patchName}`),n.log.info("diffRepos",`options.whitelistDirs: ${i.whitelistDirs}`),n.log.info("diffRepos",`options.blacklistDirs: ${i.blacklistDirs}`),n.log.info("diffRepos",`options.blacklistExts: ${i.blacklistExts}`),n.log.info("diffRepos",`options.gitExecutable: ${i.gitExecutable}`),n.log.info("diffRepos",`options.cleanupRepos: ${i.cleanupRepos}`),n.log.info("diffRepos",`options.diffExecutable: ${i.diffExecutable}`),n.log.info("diffRepos",`options.cleanupExistingPatches: ${i.cleanupExistingPatches}`);const c=o.resolvePath(e,i.patchName);o.initDirectory(c),i.cleanupRepos&&(s.cleanRepoSync(i.baseFork,i.gitExecutable),s.cleanRepoSync(i.dirtyFork,i.gitExecutable));const u=s=>{const u=o.getRelativePath(s,e),f=o.getFileNameExtension(s);if(i.blacklistExts.includes(f))return void n.log.info("diffRNFork","Ignoring {dirtyRepoFileAbsPath} based on file name extension.");o.lookUpRelativePath(t,u,e=>{const t=e=>{o.writeFile(c,u,`${e}`,"")},f=e=>{n.log.error("diffRNFork",e)},p=e=>{e?n.log.info("diffRNFork",`Skip copying identical binary files: ${u}`):o.copyFile2(c,u,s)},d=e=>{n.log.error("diffRNFork",`callbackOnBinaryFilesCompareError: ${e}`)};a.isFileBinary(s)?l.compareFiles(e,s,p,d):r.diffFiles(e,!1,s,t,f,i.diffExecutable)},e=>{const t=e=>{o.writeFile(c,u,`${e}`,"")},l=e=>{n.log.error("diffRNFork",e)};a.isFileBinary(s)?o.copyFile2(c,u,s):r.diffFiles(e,!0,s,t,l,i.diffExecutable)})},f=e=>{};0===i.whitelistDirs.length?o.traverseDirectory(e,".",u,f,i.blacklistDirs):i.whitelistDirs.forEach(t=>{i.blacklistDirs.includes(t.startsWith(".\\")?t.substr(2):t)?n.log.info("diffRNFork",`${t} is present in both whitelist as well as blacklist. Ignoring it.`):o.traverseDirectory(e,t,u,f,i.blacklistDirs)})}},function(e,t){e.exports=require("fs-extra")},function(e,t){e.exports=require("path")},function(e,t){e.exports=require("winston")},function(e,t){e.exports=require("istextorbinary")},function(e,t,i){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=o(i(2)),n=o(i(13)),a=i(0);t.compareFiles=function(e,t,i,o){try{const o=n.default.createHash("md5"),l=r.default.createReadStream(e);l.on("data",e=>{o.update(e)}),l.on("end",()=>{const l=o.digest("base64"),s=n.default.createHash("md5"),c=r.default.createReadStream(t);c.on("data",e=>{s.update(e)}),c.on("end",()=>{const o=s.digest("base64");l===o?(a.log.info("compareFiles",`${e} AND ${t} are identical.  hashes: ${l} <==> ${o}`),i(!0)):(a.log.info("compareFiles",`${e} AND ${t} are different. hashes: ${l} <==> ${o}`),i(!1))})})}catch(e){o(`${e}`)}}},function(e,t){e.exports=require("crypto")},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=i(4),r=i(0);t.cleanRepoSync=function(e,t){const i=o.spawnSync(t,["clean","-fdx"],{cwd:e});i.error&&r.log.error("cleanRepoSync",`Failed with error : ${i.error}`)}},function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=i(1),r=i(0),n=i(3),a=i(5);t.default=(e,t,i)=>{r.log.info("patchRepo",`targetRepoAbsPath: ${e}`),r.log.info("patchRepo",`patchNames: ${t}`),r.log.info("patchRepo",`options.patchStore: ${i.patchStore}`),r.log.info("patchRepo",`options.reverse: ${i.reverse}`),r.log.info("patchRepo",`options.patchExecutable: ${i.patchExecutable}`),r.log.info("patchRepo",`options.gitExecutable: ${i.gitExecutable}`),r.log.info("patchRepo",`options.cleanupRepos: ${i.cleanupRepos}`);const l=(t,l)=>{const s=o.getRelativePath(t,l);o.lookUpRelativePath(e,s,e=>{a.isFileBinary(t)?o.copyFileOverwrite(t,e):n.applyPatch(e,t,e=>{r.log.info("PatchRNFork",e)},e=>{r.log.error("PatchRNFork",e)},i.patchExecutable,i.reverse)},e=>{r.log.error("PatchRNFork",`File path with patches (${e}) not found in the target repository.`),a.isFileBinary(t)?o.copyFile(t,e):n.applyPatch(e,t,e=>{r.log.info("PatchRNFork",e)},e=>{r.log.error("PatchRNFork",e)},i.patchExecutable,i.reverse)})},s=(e,t)=>{};t.forEach(e=>{const t=o.resolvePath(i.patchStore,e);o.traverseDirectory(t,".",l,s,[])})}},function(e,t,i){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=o(i(17));i(0);r.default.version("0.0.1"),t.initCli=function(e,t){function i(e,t){return e.split(",")}r.default.command("diff <dirtyRepo> <baseRepo>").description("Diff create ..").option("-pf, --patch-name <path>","Name of the patch folder. This new folder will be created under the dirty repo","patches").option("-de, --diff-executable <path>","Full path of the diff utility to be used for diffing between files. What we expect is a *x diff utility or compatible one: http://man7.org/linux/man-pages/man1/diff.1.html","C:\\Program Files\\Git\\usr\\bin\\diff.exe").option("-ge, --git-executable <path>","Full path of the git executable","C:\\Program Files\\Git\\bin\\git.exe").option("-cc, --cleanup-repos","Whether to clean up both the dirty and base repos. It will cleanup all non-tracked files. Essentially we run 'git clean -fdx'",!1).option("-cp, --cleanup-existing-patches","Cleanup the existing patches in the patches folder before starting a new diff run",!0).option("-bl, --blacklist-dirs <paths>","Paths in dirty repo to be excluded from the patch creation and application",i,[".ado",".appveyor",".circleci",".editorconfig",".eslintignore",".eslintrc",".flowconfig",".flowconfig.android",".flowconfig.macos",".git",".gitattributes",".github",".github.flowconfig.android",".gitignore",".nvmrc",".prettierrc","bots","Brewfile","danger","double-conversion","flow","flow-typed","Folly","follybuild","glog",".gradle",".idea","jest","jest-preset.js","jest.config.js","jsc","keystores","lib","metadata","office-android-patches","packages","React","React.podspec","ReactApple","runXcodeTests.sh","stubs","third-party-podspecs","v8-docker-build","website","yarn.lock","android","node_modules","ReactAndroid\\build","ReactAndroid\\packages","RNTester\\android\\app\\build","processor\\build","local.properties"]).option("-be, --blacklist-exts <exts>","File name extensions in dirty repo to be excluded from the patch creation and application",i,[".iml"]).option("-wl, --whitelist-dirs <paths>","Paths in dirty repo to be included in the patch creation and application",i,[]).action((t,i,o)=>{e(t,i,o)}),r.default.command("patch <targetRepo> [patchNames...]").option("-ps, --patch-store <path>","Full path of the directory where the patches can be found. Each patch is a subdirectory in this directory.","E:\\github\\office-android-patches\\patches-droid-office-grouped").option("-pe, --patch-executable <path>","Full path of the patch utility to be used for patching. What we expect is a *x patch utility or compatible one: http://man7.org/linux/man-pages/man1/patch.1.html","C:\\Program Files\\Git\\usr\\bin\\patch.exe").option("-r, --reverse","Whether the patch is applied reverse",!1).option("-ge, --git-executable <path>","Full path of the git executable","C:\\Program Files\\Git\\bin\\git.exe").option("-cc, --cleanup-repos","Whether to clean up both the dirty and base repos. It will cleanup all non-tracked files. Essentially we run 'git clean -fdx'",!1).action((e,i,o)=>{t(e,i,o)}),r.default.parse(process.argv)}},function(e,t){e.exports=require("commander")}]);
//# sourceMappingURL=bundle.js.map
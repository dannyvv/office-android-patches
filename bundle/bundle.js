!function(e){var t={};function o(r){if(t[r])return t[r].exports;var n=t[r]={i:r,l:!1,exports:{}};return e[r].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.m=e,o.c=t,o.d=function(e,t,r){o.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},o.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,t){if(1&t&&(e=o(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(o.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)o.d(r,n,function(t){return e[t]}.bind(null,n));return r},o.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return o.d(t,"a",t),t},o.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},o.p="",o(o.s=10)}([function(e,t,o){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const n=r(o(12)),i=r(o(2));(()=>{const e=__dirname,t=i.default.resolve(e,".."),o=i.default.resolve(t,"logs");i.default.resolve(o,`${Date.now()}`)})(),n.default.createLogger({level:"verbose",defaultMeta:{service:"user-service"},format:n.default.format.combine(n.default.format.timestamp(),n.default.format.json()),transports:[new n.default.transports.Console({handleExceptions:!0,level:"error"})]});const a=[];const l={queryErrors:function(e){e(a)},setLogFolder:function(e){n.default.add(new n.default.transports.File({filename:"error.log",level:"error",dirname:e})),n.default.add(new n.default.transports.File({filename:"all.log",dirname:e})),n.default.exceptions.handle(new n.default.transports.File({filename:"exceptions.log",dirname:e}))},error:function(e,t){const o=`${e} - ${t}`;a.push(o),n.default.error(o)},warn:function(e,t){n.default.warn(`${e} - ${t}`)},info:function(e,t){n.default.info(`${e} - ${t}`)},verbose:function(e,t){n.default.verbose(`${e} - ${t}`)}};t.log=l},function(e,t){e.exports=require("fs-extra")},function(e,t){e.exports=require("path")},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=o(7),n=o(0),i=o(13),a=o(14),l=o(15);t.diffFiles=function(e,t,o,i,a,l){const s=[e,o,"-u"];t&&s.push("--unidirectional-new-file");const c=r.spawn(l,s);c.stdout.on("data",e=>{i(e)}),c.stderr.on("data",e=>{a(`${l} ${s} failed with message: ${e}`)}),c.on("close",e=>{n.log.verbose("Patch",`git child process exited with code ${e}`)})},t.applyPatchTool=function(e,t,o,i,a,l){const s=["-i",t,e,"-s"];l&&s.push("-R");const c=r.spawn(a,s);n.log.info("Patch","Calling C:\\Program Files\\Git\\usr\\bin\\patch.exe "+s.toString()),c.on("message",e=>{o(`Patch message: ${e}`)}),c.stdout.on("data",e=>{o(`Patch output: ${e}`)}),c.stderr.on("data",e=>{i(`${a} ${s} failed with message: ${e}`)}),c.on("close",e=>{n.log.info("Patch",`patch child process exited with code ${e}`)})},t.applyPatchEmbedded=function({patchFilePath:e,targetFilePathOverride:t,reverse:o}){const r=l.readPatch({patchFilePath:e});try{i.executeEffects(o?a.reversePatch(r):r,t,{dryRun:!1})}catch(e){try{i.executeEffects(o?r:a.reversePatch(r),t,{dryRun:!0})}catch(e){return n.log.error("patch_utils",`Applying patch failed: ${e}`),!1}}return!0}},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=o(0);t.assertNever=function(e){throw r.log.error("assertNever","Unexpected object: "+e),new Error("Unexpected object: "+e)}},function(e,t,o){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const n=r(o(6)),i=r(o(1)),a=r(o(2)),l=o(0);function s(e,t){return a.default.resolve(e,t)}function c(e){try{return n.default.lstatSync(e).isDirectory()}catch(t){l.log.error("FS:isDirectory",`${e}::${t}`)}}function d(e){try{return n.default.lstatSync(e).isFile()}catch(t){l.log.error("FS:isRegularFile",`${e}::${t}`)}}function f(e){try{return n.default.lstatSync(e).isSymbolicLink()}catch(t){l.log.error("FS:isSymlink",`${e}::${t}`)}}function u(e){const t=a.default.parse(e).dir;i.default.ensureDirSync(t)}t.getDirectoryFromFilePath=function(e){return a.default.basename(e)},t.getFileNameExtension=function(e){return a.default.extname(e)},t.resolvePath=s,t.isDirectory=c,t.isRegularFile=d,t.isSymlink=f,t.getRelativePath=function(e,t){return a.default.relative(t,e)},t.writeFile=function(e,t,o,r){try{const s=a.default.basename(t),c=a.default.parse(t).dir,d=a.default.resolve(e,c);n.default.existsSync(d)||i.default.ensureDirSync(d);const f=a.default.resolve(d,r?`${s}.${r}`:s);n.default.existsSync(f)&&l.log.error("FS:writeFile",`Trying to write to file which already exists: ${f}`),n.default.writeFileSync(f,o)}catch(o){l.log.error("FS:writeFile",`File Writing Failed::${e}::${t}::${o}`)}},t.traverseDirectory=function e(t,o,r,i,u=[],p=!0){l.log.verbose("traverseDirectory",`Entering ${t}\\${o}`);const h=s(t,o);if(d(h))r(h,t);else if(c(h)){n.default.readdirSync(h).forEach(n=>{const s=a.default.resolve(h,n),c=o+"\\"+n;u.includes(c.startsWith(".\\")?c.substr(2):c)?l.log.verbose("traverseDirectory",`Ignoring ${t}\\${c} as it's blacklisted.`):(i(s,t),p&&e(t,c,r,i,u,p))})}else f(h)&&l.log.error("FS:traverseDirectory",`We currently dont support symlinks: ${h}`)},t.lookUpRelativePath=function(e,t,o,r){const i=a.default.resolve(e,t);n.default.existsSync(i)?o(i):r(i)},t.initDirectory=function(e){i.default.removeSync(e),i.default.existsSync(e)&&l.log.error("FS:initDirectory",`Output directory can't be nuked !! (${e})`),i.default.ensureDirSync(e)},t.copyFile=function(e,t){u(t),i.default.copyFileSync(e,t)},t.copyFileOverwrite=function(e,t){u(t),n.default.existsSync(t)||l.log.error("FS:copyFileOverwrite",`Trying to overwrite file but the target doesn't already exist (${t})!`),i.default.copyFileSync(e,t)},t.copyFile2=function(e,t,o){const r=a.default.parse(t).dir,s=a.default.resolve(e,r);n.default.existsSync(s)||i.default.ensureDirSync(s);const c=a.default.resolve(e,t);n.default.existsSync(c)&&l.log.error("FS:copyFile2",`Trying to copy binary file but it already exists (${o})!`),i.default.copyFileSync(o,c)},t.copyFile2Overwrite=function(e,t,o){const r=a.default.parse(t).dir,s=a.default.resolve(e,r);n.default.existsSync(s)||i.default.ensureDirSync(s);const c=a.default.resolve(e,t);n.default.existsSync(c)||l.log.error("FS:copyFile2Overwrite",`Trying to overwrite file but the target doesn't already exist (${t})!`),i.default.copyFileSync(o,c)}},function(e,t){e.exports=require("fs")},function(e,t){e.exports=require("child_process")},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=o(4);t.parseHunkHeaderLine=e=>{const t=e.trim().match(/^@@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))? @@.*/);if(!t)throw new Error(`Bad header line: '${e}'`);return{original:{start:Math.max(Number(t[1]),1),length:Number(t[3]||1)},patched:{start:Math.max(Number(t[4]),1),length:Number(t[6]||1)}}},t.NON_EXECUTABLE_FILE_MODE=420,t.EXECUTABLE_FILE_MODE=493;const n={"@":"header","-":"deletion","+":"insertion"," ":"context","\\":"pragma",undefined:"context"};function i(e,{supportLegacyDiffs:o}){const i=[];let a={diffLineFromPath:null,diffLineToPath:null,oldMode:null,newMode:null,deletedFileMode:null,newFileMode:null,renameFrom:null,renameTo:null,beforeHash:null,afterHash:null,fromPath:null,toPath:null,hunks:null},l="parsing header",c=null,d=null;function f(){c&&(d&&(c.parts.push(d),d=null),a.hunks.push(c),c=null)}function u(){f(),i.push(a),a={diffLineFromPath:null,diffLineToPath:null,oldMode:null,newMode:null,deletedFileMode:null,newFileMode:null,renameFrom:null,renameTo:null,beforeHash:null,afterHash:null,fromPath:null,toPath:null,hunks:null}}for(let i=0;i<e.length;i++){const s=e[i];if("parsing header"===l)if(s.startsWith("@@"))l="parsing hunks",a.hunks=[],i--;else if(s.startsWith("diff --git ")){a&&a.diffLineFromPath&&u();const e=s.match(/^diff --git a\/(.*?) b\/(.*?)\s*$/);if(!e)throw new Error("Bad diff line: "+s);a.diffLineFromPath=e[1],a.diffLineToPath=e[2]}else if(s.startsWith("old mode "))a.oldMode=s.slice("old mode ".length).trim();else if(s.startsWith("new mode "))a.newMode=s.slice("new mode ".length).trim();else if(s.startsWith("deleted file mode "))a.deletedFileMode=s.slice("deleted file mode ".length).trim();else if(s.startsWith("new file mode "))a.newFileMode=s.slice("new file mode ".length).trim();else if(s.startsWith("rename from "))a.renameFrom=s.slice("rename from ".length).trim();else if(s.startsWith("rename to "))a.renameTo=s.slice("rename to ".length).trim();else if(s.startsWith("index ")){const e=s.match(/(\w+)\.\.(\w+)/);if(!e)continue;a.beforeHash=e[1],a.afterHash=e[2]}else s.startsWith("--- ")?a.fromPath=s.slice("--- a/".length).trim():s.startsWith("+++ ")&&(a.toPath=s.slice("+++ b/".length).trim());else{if(o&&s.startsWith("--- a/")){l="parsing header",u(),i--;continue}const e=n[s[0]]||null;switch(e){case"header":f(),p=s,c={header:t.parseHunkHeaderLine(p),parts:[]};break;case null:l="parsing header",u(),i--;break;case"pragma":if(!s.startsWith("\\ No newline at end of file"))throw new Error("Unrecognized pragma in patch file: "+s);if(!d)throw new Error("Bad parser state: No newline at EOF pragma encountered without context");d.noNewlineAtEndOfFile=!0;break;case"insertion":case"deletion":case"context":if(!c)throw new Error("Bad parser state: Hunk lines encountered before hunk header");d&&d.type!==e&&(c.parts.push(d),d=null),d||(d={type:e,lines:[],noNewlineAtEndOfFile:!1}),d.lines.push(s.slice(1));break;default:r.assertNever(e)}}}var p;u();for(const{hunks:e}of i)if(e)for(const t of e)s(t);return i}function a(e){const t=[];for(const o of e){const{diffLineFromPath:e,diffLineToPath:n,oldMode:i,newMode:a,deletedFileMode:s,newFileMode:c,renameFrom:d,renameTo:f,beforeHash:u,afterHash:p,fromPath:h,toPath:g,hunks:y}=o,m=d?"rename":s?"file deletion":c?"file creation":y&&y.length>0?"patch":"mode change";let b=null;switch(m){case"rename":if(!d||!f)throw new Error("Bad parser state: rename from & to not given");t.push({type:"rename",fromPath:d,toPath:f}),b=f;break;case"file deletion":{const o=e||h;if(!o)throw new Error("Bad parse state: no path given for file deletion");t.push({type:"file deletion",hunk:y&&y[0]||null,path:o,mode:l(s),hash:u});break}case"file creation":{const e=n||g;if(!e)throw new Error("Bad parse state: no path given for file creation");t.push({type:"file creation",hunk:y&&y[0]||null,path:e,mode:l(c),hash:p});break}case"patch":case"mode change":b=g||n;break;default:r.assertNever(m)}b&&i&&a&&i!==a&&t.push({type:"mode change",path:b,oldMode:l(i),newMode:l(a)}),b&&y&&y.length&&t.push({type:"patch",path:b,hunks:y,beforeHash:u,afterHash:p})}return t}function l(e){const o=511&parseInt(e,8);if(o!==t.NON_EXECUTABLE_FILE_MODE&&o!==t.EXECUTABLE_FILE_MODE)throw new Error("Unexpected file mode string: "+e);return o}function s(e){let t=0,o=0;for(const{type:n,lines:i}of e.parts)switch(n){case"context":o+=i.length,t+=i.length;break;case"deletion":t+=i.length;break;case"insertion":o+=i.length;break;default:r.assertNever(n)}if(t!==e.header.original.length||o!==e.header.patched.length)throw new Error("hunk header integrity check failed")}t.interpretParsedPatchFile=a,t.parsePatchFile=function(e){const t=e.split(/\n/g);""===t[t.length-1]&&t.pop();try{return a(i(t,{supportLegacyDiffs:!1}))}catch(e){if(e instanceof Error&&"hunk header integrity check failed"===e.message)return a(i(t,{supportLegacyDiffs:!0}));throw e}},t.verifyHunkIntegrity=s},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=o(16);t.isFileText=function(e){return r.isTextSync(e)},t.isFileBinary=function(e){return r.isBinarySync(e)}},function(e,t,o){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const n=r(o(11)),i=r(o(20)),a=r(o(21)),l=o(22),s=o(0);l.initCli(n.default,i.default,a.default,()=>{s.log.queryErrors(e=>{e.length>0&&(process.exitCode=-1,e.forEach(e=>{process.stderr.write(e+"\n")}))})})},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=o(5),n=o(3),i=o(0),a=o(9),l=o(17),s=o(19);t.default=(e,t,o)=>{i.log.info("diffRepos",`dirtyRepoAbsPath: ${e}`),i.log.info("diffRepos",`baseRepoAbsPath: ${t}`),i.log.info("diffRepos",`options.patchName: ${o.patchName}`),i.log.info("diffRepos",`options.whitelistDirs: ${o.whitelistDirs}`),i.log.info("diffRepos",`options.blacklistDirs: ${o.blacklistDirs}`),i.log.info("diffRepos",`options.blacklistExts: ${o.blacklistExts}`),i.log.info("diffRepos",`options.gitExecutable: ${o.gitExecutable}`),i.log.info("diffRepos",`options.cleanupRepos: ${o.cleanupRepos}`),i.log.info("diffRepos",`options.diffExecutable: ${o.diffExecutable}`),i.log.info("diffRepos",`options.cleanupExistingPatches: ${o.cleanupExistingPatches}`);const c=r.resolvePath(e,o.patchName);r.initDirectory(c),o.cleanupRepos&&(s.cleanRepoSync(o.baseFork,o.gitExecutable),s.cleanRepoSync(o.dirtyFork,o.gitExecutable));const d=s=>{const d=r.getRelativePath(s,e),f=r.getFileNameExtension(s);if(o.blacklistExts.includes(f))return void i.log.info("diffRNFork","Ignoring {dirtyRepoFileAbsPath} based on file name extension.");r.lookUpRelativePath(t,d,e=>{const t=e=>{r.writeFile(c,d,`${e}`,"")},f=e=>{i.log.error("diffRNFork",e)},u=e=>{e?i.log.info("diffRNFork",`Skip copying identical binary files: ${d}`):r.copyFile2(c,d,s)},p=e=>{i.log.error("diffRNFork",`callbackOnBinaryFilesCompareError: ${e}`)};a.isFileBinary(s)?l.compareFiles(e,s,u,p):n.diffFiles(e,!1,s,t,f,o.diffExecutable)},e=>{const t=e=>{r.writeFile(c,d,`${e}`,"")},l=e=>{i.log.error("diffRNFork",e)};a.isFileBinary(s)?r.copyFile2(c,d,s):n.diffFiles(e,!0,s,t,l,o.diffExecutable)})},f=e=>{};0===o.whitelistDirs.length?r.traverseDirectory(e,".",d,f,o.blacklistDirs):o.whitelistDirs.forEach(t=>{o.blacklistDirs.includes(t.startsWith(".\\")?t.substr(2):t)?i.log.info("diffRNFork",`${t} is present in both whitelist as well as blacklist. Ignoring it.`):r.traverseDirectory(e,t,d,f,o.blacklistDirs)})}},function(e,t){e.exports=require("winston")},function(e,t,o){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const n=r(o(1)),i=o(2),a=o(4),l=o(0);function s(e){return(64&e)>0}t.executeEffects=(e,t,{dryRun:o})=>{e.forEach(e=>{switch(e.type){case"file deletion":if(o){if(!n.default.existsSync(e.path))throw new Error("Trying to delete file that doesn't exist: "+e.path)}else n.default.unlinkSync(e.path);break;case"rename":if(o){if(!n.default.existsSync(e.fromPath))throw new Error("Trying to move file that doesn't exist: "+e.fromPath)}else n.default.moveSync(e.fromPath,e.toPath);break;case"file creation":if(o){if(n.default.existsSync(e.path))throw new Error("Trying to create file that already exists: "+e.path)}else{const t=e.hunk?e.hunk.parts[0].lines.join("\n")+(e.hunk.parts[0].noNewlineAtEndOfFile?"":"\n"):"";n.default.ensureDirSync(i.dirname(e.path)),n.default.writeFileSync(e.path,t,{mode:e.mode})}break;case"patch":l.log.info("patch\\apply","Patches found."),function({hunks:e,path:t},o,{dryRun:r}){const s=o||t;let c="",f=0;n.default.existsSync(o)&&(c=n.default.readFileSync(o).toString(),f=n.default.statSync(o).mode);const u=c.split(/\n/),p=[];for(const t of e){let o=0;for(;;){const r=d(t,u,o);if(r){p.push(r);break}if(o=o<0?-1*o:-1*o-1,Math.abs(o)>20)throw new Error(`Cant apply hunk ${e.indexOf(t)} for file ${s}`)}}if(r)return;let h=0;for(const e of p)for(const t of e)switch(t.type){case"splice":u.splice(t.index+h,t.numToDelete,...t.linesToInsert),h+=t.linesToInsert.length-t.numToDelete;break;case"pop":l.log.verbose("patch\\apply","Removing lines"),u.pop();break;case"push":l.log.verbose("patch\\apply","Adding lines"),u.push(t.line);break;default:a.assertNever(t)}n.default.ensureDirSync(i.dirname(o)),n.default.writeFileSync(o,u.join("\n"),{mode:f})}(e,t,{dryRun:o});break;case"mode change":const r=n.default.statSync(e.path).mode;(s(e.newMode)&&s(r)||!s(e.newMode)&&!s(r))&&o&&console.warn(`Mode change is not required for file ${e.path}`),n.default.chmodSync(e.path,e.newMode);break;default:a.assertNever(e)}})};const c=e=>e.replace(/\s+$/,"");function d(e,t,o){const r=[];let n=e.header.original.start-1+o;if(n<0)return null;if(t.length-n<e.header.original.length)return null;for(const o of e.parts)switch(o.type){case"deletion":case"context":for(const e of o.lines){const o=t[n];if(i=e,c(o)!==c(i))return null;n++}"deletion"===o.type&&(r.push({type:"splice",index:n-o.lines.length,numToDelete:o.lines.length,linesToInsert:[]}),o.noNewlineAtEndOfFile&&r.push({type:"push",line:""}));break;case"insertion":r.push({type:"splice",index:n,numToDelete:0,linesToInsert:o.lines}),o.noNewlineAtEndOfFile&&r.push({type:"pop"});break;default:a.assertNever(o.type)}var i;return r}},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=o(8),n=o(4);function i(e){const t={original:e.header.patched,patched:e.header.original},o=[];for(const t of e.parts)switch(t.type){case"context":o.push(t);break;case"deletion":o.push({type:"insertion",lines:t.lines,noNewlineAtEndOfFile:t.noNewlineAtEndOfFile});break;case"insertion":o.push({type:"deletion",lines:t.lines,noNewlineAtEndOfFile:t.noNewlineAtEndOfFile});break;default:n.assertNever(t.type)}for(let e=0;e<o.length-1;e++)if("insertion"===o[e].type&&"deletion"===o[e+1].type){const t=o[e];o[e]=o[e+1],o[e+1]=t,e+=1}const i={header:t,parts:o};return r.verifyHunkIntegrity(i),i}function a(e){switch(e.type){case"file creation":return{type:"file deletion",path:e.path,hash:e.hash,hunk:e.hunk&&i(e.hunk),mode:e.mode};case"file deletion":return{type:"file creation",path:e.path,hunk:e.hunk&&i(e.hunk),mode:e.mode,hash:e.hash};case"rename":return{type:"rename",fromPath:e.toPath,toPath:e.fromPath};case"patch":return{type:"patch",path:e.path,hunks:e.hunks.map(i),beforeHash:e.afterHash,afterHash:e.beforeHash};case"mode change":return{type:"mode change",path:e.path,newMode:e.oldMode,oldMode:e.newMode}}}t.reversePatch=e=>e.map(a).reverse()},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=o(1),n=o(8);t.readPatch=function({patchFilePath:e}){try{return n.parsePatchFile(r.readFileSync(e).toString())}catch(e){process.exit(1)}return[]}},function(e,t){e.exports=require("istextorbinary")},function(e,t,o){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const n=r(o(6)),i=r(o(18)),a=o(0);t.compareFiles=function(e,t,o,r){try{const r=i.default.createHash("md5"),l=n.default.createReadStream(e);l.on("data",e=>{r.update(e)}),l.on("end",()=>{const l=r.digest("base64"),s=i.default.createHash("md5"),c=n.default.createReadStream(t);c.on("data",e=>{s.update(e)}),c.on("end",()=>{const r=s.digest("base64");l===r?(a.log.info("compareFiles",`${e} AND ${t} are identical.  hashes: ${l} <==> ${r}`),o(!0)):(a.log.info("compareFiles",`${e} AND ${t} are different. hashes: ${l} <==> ${r}`),o(!1))})})}catch(e){r(`${e}`)}}},function(e,t){e.exports=require("crypto")},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=o(7),n=o(0);t.cleanRepoSync=function(e,t){const o=r.spawnSync(t,["clean","-fdx"],{cwd:e});o.error&&n.log.error("cleanRepoSync",`Failed with error : ${o.error}`)}},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=o(5),n=o(0),i=o(3),a=o(9);function l(e,t,o,r,a){if(n.log.info("PatchRepo",`Applying ${t} on ${e} `),o.embeddedPatcher){i.applyPatchEmbedded({patchFilePath:t,targetFilePathOverride:e,reverse:o.reverse})||n.log.error("PatchRepo",`Applying ${t} on ${e} failed.`)}else i.applyPatchTool(e,t,e=>{n.log.info("PatchRepo",e)},e=>{n.log.error("PatchRepo",e)},o.patchExecutable,o.reverse)}t.default=(e,t,o)=>{n.log.info("patchRepo",`targetRepoAbsPath: ${e}`),n.log.info("patchRepo",`patchNames: ${t}`),n.log.info("patchRepo",`options.patchStore: ${o.patchStore}`),n.log.info("patchRepo",`enbeddedPatcher?: ${o.embeddedPatcher}`),n.log.info("patchRepo",`options.reverse: ${o.reverse}`),n.log.info("patchRepo",`options.patchExecutable: ${o.patchExecutable}`),n.log.info("patchRepo",`options.gitExecutable: ${o.gitExecutable}`),n.log.info("patchRepo",`options.cleanupRepos: ${o.cleanupRepos}`);const i=(t,i)=>{const s=r.getRelativePath(t,i);r.lookUpRelativePath(e,s,e=>{a.isFileBinary(t)?r.copyFileOverwrite(t,e):l(e,t,o)},e=>{n.log.warn("PatchRepo",`File path with patches (${e}) not found in the target repository.`),a.isFileBinary(t)?r.copyFile(t,e):l(e,t,o)})},s=(e,t)=>{};t.forEach(e=>{const t=r.resolvePath(o.patchStore,e);r.traverseDirectory(t,".",i,s,[])})}},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=o(0),n=o(3);t.default=(e,t,o)=>{r.log.info("patchFile",`targetFileAbsPath: ${e}`),r.log.info("patchFile",`patchFileAbsPath: ${t}`),r.log.info("patchFile",`enbeddedPatcher?: ${o.embeddedPatcher}`),r.log.info("patchFile",`options.reverse: ${o.reverse}`),r.log.info("patchFile",`options.patchExecutable: ${o.patchExecutable}`),function(e,t,o,i,a){if(r.log.info("patchFile",`Applying ${t} on ${e} with options ${o}`),o.embeddedPatcher){n.applyPatchEmbedded({patchFilePath:t,targetFilePathOverride:e,reverse:o.reverse})||r.log.error("patchFile",`Applying ${t} on ${e} failed.`)}else n.applyPatchTool(e,t,e=>{r.log.info("patchFile",e)},e=>{r.log.error("patchFile",e)},o.patchExecutable,o.reverse)}(e,t,o)}},function(e,t,o){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const n=r(o(23)),i=o(0);n.default.version("0.0.1"),t.initCli=function(e,t,o,r){function a(e,t){return e.split(",")}n.default.command("diff <dirtyRepo> <baseRepo>").description("Diff create ..").option("--patch-name <path>","Name of the patch folder. This new folder will be created under the dirty repo","patches").option("--diff-executable <path>","Full path of the diff utility to be used for diffing between files. What we expect is a *x diff utility or compatible one: http://man7.org/linux/man-pages/man1/diff.1.html","C:\\Program Files\\Git\\usr\\bin\\diff.exe").option("--git-executable <path>","Full path of the git executable","C:\\Program Files\\Git\\bin\\git.exe").option("--cleanup-repos","Whether to clean up both the dirty and base repos. It will cleanup all non-tracked files. Essentially we run 'git clean -fdx'",!1).option("--cleanup-existing-patches","Cleanup the existing patches in the patches folder before starting a new diff run",!0).option("--blacklist-dirs <paths>","Paths in dirty repo to be excluded from the patch creation and application",a,[".ado",".appveyor",".circleci",".editorconfig",".eslintignore",".eslintrc",".flowconfig",".flowconfig.android",".flowconfig.macos",".git",".gitattributes",".github",".github.flowconfig.android",".gitignore",".nvmrc",".prettierrc","bots","Brewfile","danger","double-conversion","flow","flow-typed","Folly","follybuild","glog",".gradle",".idea","jest","jest-preset.js","jest.config.js","jsc","keystores","lib","metadata","office-android-patches","packages","React","React.podspec","ReactApple","runXcodeTests.sh","stubs","third-party-podspecs","v8-docker-build","website","yarn.lock","android","node_modules","ReactAndroid\\build","ReactAndroid\\packages","RNTester\\android\\app\\build","processor\\build","local.properties"]).option("--blacklist-exts <exts>","File name extensions in dirty repo to be excluded from the patch creation and application",a,[".iml"]).option("--whitelist-dirs <paths>","Paths in dirty repo to be included in the patch creation and application",a,[]).option("--log-folder <path>","Log Folder").action((t,o,n)=>{i.log.setLogFolder(n.logFolder),e(t,o,n),r()}),n.default.command("patch <targetRepo> [patchNames...]").option("--patch-store <path>","Full path of the directory where the patches can be found. Each patch is a subdirectory in this directory.","E:\\github\\office-android-patches\\patches-droid-office-grouped").option("--no-embedded-patcher","If true, use the embedded patching code written in Javascript. Currently, this code is taken from the source code the popular package : 'https://github.com/ds300/patch-package'. And adapted. Thanks !").option("--patch-executable <path>","Full path of the patch utility to be used for patching. What we expect is a *x patch utility or compatible one: http://man7.org/linux/man-pages/man1/patch.1.html. Used only if embeddedPatcher is set to false.","C:\\Program Files\\Git\\usr\\bin\\patch.exe").option("--reverse","Whether the patch is applied reverse",!1).option("--git-executable <path>","Full path of the git executable","C:\\Program Files\\Git\\bin\\git.exe").option("--cleanup-repos","Whether to clean up both the dirty and base repos. It will cleanup all non-tracked files. Essentially we run 'git clean -fdx'",!1).option("--log-folder <path>","Log Folder").action((e,o,n)=>{i.log.setLogFolder(n.logFolder),t(e,o,n),r()}),n.default.command("patchfile <targetFilePath> <patchFilePath>").option("--no-embedded-patcher","If true, use the embedded patching code written in Javascript. Currently, this code is taken from the source code the popular package : 'https://github.com/ds300/patch-package'. And adapted. Thanks !").option("--patch-executable <path>","Full path of the patch utility to be used for patching. What we expect is a *x patch utility or compatible one: http://man7.org/linux/man-pages/man1/patch.1.html. Used only if embeddedPatcher is set to false.","C:\\Program Files\\Git\\usr\\bin\\patch.exe").option("--reverse","Whether the patch is applied reverse",!1).option("--log-folder <path>","Log Folder").action((e,t,n)=>{i.log.setLogFolder(n.logFolder),o(e,t,n),r()}),n.default.parse(process.argv)}},function(e,t){e.exports=require("commander")}]);
//# sourceMappingURL=bundle.js.map
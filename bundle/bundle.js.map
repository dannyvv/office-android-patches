{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/logger.ts","webpack:///./src/fs_utils.ts","webpack:///external \"fs\"","webpack:///./src/patch_utils.ts","webpack:///external \"child_process\"","webpack:///./src/file_type_utils.ts","webpack:///./src/index.ts","webpack:///./src/diffRepos.ts","webpack:///external \"fs-extra\"","webpack:///external \"path\"","webpack:///external \"winston\"","webpack:///external \"istextorbinary\"","webpack:///./src/file_compare.ts","webpack:///external \"crypto\"","webpack:///./src/git_utils.ts","webpack:///./src/patchRepo.ts","webpack:///./src/cli.ts","webpack:///external \"commander\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","logger","createLogger","level","defaultMeta","service","format","combine","timestamp","json","transports","File","filename","dirname","Date","now","log","error","prefix","message","info","verbose","resolvePath","base","relative","resolve","isDirectory","path","lstatSync","e","isRegularFile","isFile","isSymlink","isSymbolicLink","ensureDirOfPathExists","filePath","dir","parse","ensureDirSync","extname","absPath","basepath","relativefilepath","data","extension","basename","relative_dir","absPath1","existsSync","absPath2","writeFileSync","traverseDirectory","rootAbsPath","relPath","callbackFile","callbackDirectory","blackListDirs","recursive","readdirSync","forEach","childpath","absChildPath","relChildPath","includes","startsWith","substr","relativePath","callbackOnHit","callbackOnMiss","removeSync","absSourecPath","absDestinationPath","copyFileSync","destBasepath","destRelativefilepath","sourcePath","destRelativeDir","destAbsDir","destAbsPath","require","path1","path1IsNew","path2","callback","errorcallback","diffExecutable","diffArgs","push","diff","spawn","stdout","on","stderr","code","targetPath","patchPath","patchExecutable","reverse","patchArgs","patch","toString","filepath","isTextSync","isBinarySync","initCli","dirtyRepoAbsPath","baseRepoAbsPath","options","patchName","whitelistDirs","blacklistDirs","blacklistExts","gitExecutable","cleanupRepos","cleanupExistingPatches","patchStorePath","initDirectory","cleanRepoSync","baseFork","dirtyFork","dirtyRepoFileAbsPath","forkFileRelativePath","getRelativePath","fileNameExtension","getFileNameExtension","lookUpRelativePath","fbRepoFileAbsPath","callbackOnDiffCreated","writeFile","callbackOnError","callbackOnBinaryFilesCompare","same","copyFile2","callbackOnBinaryFilesCompareError","result","isFileBinary","compareFiles","diffFiles","length","hash1","createHash","stream1","createReadStream","update","hash1Digest","digest","hash2","stream2","hash2Digest","gitClean","spawnSync","cwd","targetRepoAbsPath","patchNames","patchStore","patchFileAbsPath","patchFileRootAbsPath","patchFileRelativePath","hitPatchFileAbsPath","copyFileOverwrite","applyPatch","missedPatchFileAbsPath","copyFile","patchNameDirAbsPath","version","diffReposFunc","patchRepoFunc","commaSeparatedList","dummyPrevious","split","command","description","option","action","dirtyRepo","baseRepo","cmdObject","targetRepo","process","argv"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","import winston from 'winston';\n\nconst logger = winston.createLogger({\n  level: 'verbose',\n  defaultMeta: {service: 'user-service'},\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json(),\n  ),\n  transports: [\n    //\n    // - Write all logs with level `error` and below to `error.log`\n    // - Write all logs with level `info` and below to `combined.log`\n    //\n    new winston.transports.File({\n      filename: 'error.log',\n      level: 'error',\n      dirname: 'logs',\n    }),\n    new winston.transports.File({\n      filename: `combined.log`,\n      dirname: `logs\\\\${Date.now()}`,\n    }),\n  ],\n});\n\nfunction info(prefix: string, message: string) {\n  logger.info(`${prefix} - ${message}`);\n}\n\nfunction verbose(prefix: string, message: string) {\n  logger.verbose(`${prefix} - ${message}`);\n}\n\nfunction error(prefix: string, message: string) {\n  logger.error(`${prefix} - ${message}`);\n}\n\nconst log = {error, info, verbose};\nexport {log};\n","import fs from 'fs';\nimport fse from 'fs-extra';\nimport fs_path from 'path';\nimport {pathToFileURL} from 'url';\nimport {log} from './logger';\n\nexport function getFileNameExtension(path: string): string {\n  return fs_path.extname(path);\n}\n\nexport function resolvePath(base: string, relative: string): string {\n  return fs_path.resolve(base, relative);\n}\n\nexport function isDirectory(path: string) {\n  try {\n    return fs.lstatSync(path).isDirectory();\n  } catch (e) {\n    log.error('FS:isDirectory', `${path}::${e}`);\n  }\n}\n\nexport function isRegularFile(path: string) {\n  try {\n    return fs.lstatSync(path).isFile();\n  } catch (e) {\n    log.error('FS:isRegularFile', `${path}::${e}`);\n  }\n}\n\nexport function isSymlink(path: string) {\n  try {\n    return fs.lstatSync(path).isSymbolicLink();\n  } catch (e) {\n    log.error('FS:isSymlink', `${path}::${e}`);\n  }\n}\n\nexport function getRelativePath(absPath: string, base: string) {\n  return fs_path.relative(base, absPath);\n}\n\n//\nexport function writeFile(\n  basepath: string,\n  relativefilepath: string,\n  data: string,\n  extension?: string /* Optional extension to be added to the relativefilepath */,\n) {\n  try {\n    // const name2 = 'patch-' + name.replace(/[ &\\/\\\\#,+()$~%.'\":*?<>{}]/g, '-');\n    const name = fs_path.basename(relativefilepath);\n    const relative_dir = fs_path.parse(relativefilepath).dir;\n\n    // Create directory if not exists.\n    const absPath1 = fs_path.resolve(basepath, relative_dir);\n    if (!fs.existsSync(absPath1)) {\n      fse.ensureDirSync(absPath1);\n    }\n\n    const absPath2 = fs_path.resolve(\n      absPath1,\n      extension ? `${name}.${extension}` : name,\n    );\n\n    if (fs.existsSync(absPath2)) {\n      log.error(\n        'FS:writeFile',\n        `Trying to write to file which already exists: ${absPath2}`,\n      );\n    }\n\n    fs.writeFileSync(absPath2, data);\n  } catch (e) {\n    log.error(\n      'FS:writeFile',\n      `File Writing Failed::${basepath}::${relativefilepath}::${e}`,\n    );\n  }\n}\n\n// Note :: Assuming the input path is an absolute path.\n// And callback gets called with absolute path\nexport function traverseDirectory(\n  rootAbsPath: string,\n  relPath: string,\n  callbackFile: (path: string, root: string) => void,\n  callbackDirectory: (path: string, root: string) => void,\n  blackListDirs: string[] = [],\n  recursive: boolean = true,\n) {\n  log.verbose('traverseDirectory', `Entering ${rootAbsPath}\\\\${relPath}`);\n  const path = resolvePath(rootAbsPath, relPath);\n  if (isRegularFile(path)) {\n    callbackFile(path, rootAbsPath);\n  } else if (isDirectory(path)) {\n    const children = fs.readdirSync(path);\n    children.forEach((childpath: string) => {\n      const absChildPath = fs_path.resolve(path, childpath);\n      const relChildPath = relPath + '\\\\' + childpath;\n\n      // Ignore the '.\\' prefix when doing black list comparison\n      if (\n        blackListDirs.includes(\n          relChildPath.startsWith('.\\\\')\n            ? relChildPath.substr(2)\n            : relChildPath,\n        )\n      ) {\n        log.verbose(\n          'traverseDirectory',\n          `Ignoring ${rootAbsPath}\\\\${relChildPath} as it's blacklisted.`,\n        );\n        return;\n      }\n\n      callbackDirectory(absChildPath, rootAbsPath);\n      if (recursive)\n        traverseDirectory(\n          rootAbsPath,\n          relChildPath,\n          callbackFile,\n          callbackDirectory,\n          blackListDirs,\n          recursive,\n        );\n    });\n  } else if (isSymlink(path)) {\n    log.error(\n      'FS:traverseDirectory',\n      `We currently dont support symlinks: ${path}`,\n    );\n  }\n}\n\n// Note :: Lookup a relative path in a give root path\nexport function lookUpRelativePath(\n  path: string,\n  relativePath: string,\n  callbackOnHit: (path: string) => void,\n  callbackOnMiss: (path: string) => void,\n) {\n  const absChildPath = fs_path.resolve(path, relativePath);\n  if (!fs.existsSync(absChildPath)) {\n    callbackOnMiss(absChildPath);\n  } else {\n    callbackOnHit(absChildPath);\n  }\n}\n\nexport function initDirectory(path: string) {\n  fse.removeSync(path);\n  if (fse.existsSync(path)) {\n    log.error(\n      'FS:initDirectory',\n      `Output directory can't be nuked !! (${path})`,\n    );\n  }\n  fse.ensureDirSync(path);\n}\n\nfunction ensureDirOfPathExists(filePath: string) {\n  const dir = fs_path.parse(filePath).dir;\n  fse.ensureDirSync(dir);\n}\n\nexport function copyFile(absSourecPath: string, absDestinationPath: string) {\n  ensureDirOfPathExists(absDestinationPath);\n  fse.copyFileSync(absSourecPath, absDestinationPath);\n}\n\nexport function copyFileOverwrite(\n  absSourecPath: string,\n  absDestinationPath: string,\n) {\n  ensureDirOfPathExists(absDestinationPath);\n  if (!fs.existsSync(absDestinationPath)) {\n    log.error(\n      'FS:copyFileOverwrite',\n      `Trying to overwrite file but the target doesn't already exist (${absDestinationPath})!`,\n    );\n  }\n  fse.copyFileSync(absSourecPath, absDestinationPath);\n}\n\nexport function copyFile2(\n  destBasepath: string,\n  destRelativefilepath: string,\n  sourcePath: string,\n) {\n  // Ensure the directory exists.\n  const destRelativeDir = fs_path.parse(destRelativefilepath).dir;\n\n  // Create directory if not exists.\n  const destAbsDir = fs_path.resolve(destBasepath, destRelativeDir);\n  if (!fs.existsSync(destAbsDir)) {\n    fse.ensureDirSync(destAbsDir);\n  }\n\n  const destAbsPath = fs_path.resolve(destBasepath, destRelativefilepath);\n  if (fs.existsSync(destAbsPath)) {\n    log.error(\n      'FS:copyFile2',\n      `Trying to copy binary file but it already exists (${sourcePath})!`,\n    );\n  }\n\n  fse.copyFileSync(sourcePath, destAbsPath);\n}\n\nexport function copyFile2Overwrite(\n  destBasepath: string,\n  destRelativefilepath: string,\n  sourcePath: string,\n) {\n  // Ensure the directory exists.\n  const destRelativeDir = fs_path.parse(destRelativefilepath).dir;\n\n  // Create directory if not exists.\n  const destAbsDir = fs_path.resolve(destBasepath, destRelativeDir);\n  if (!fs.existsSync(destAbsDir)) {\n    fse.ensureDirSync(destAbsDir);\n  }\n\n  const destAbsPath = fs_path.resolve(destBasepath, destRelativefilepath);\n  if (!fs.existsSync(destAbsPath)) {\n    log.error(\n      'FS:copyFile2Overwrite',\n      `Trying to overwrite file but the target doesn't already exist (${destRelativefilepath})!`,\n    );\n  }\n\n  fse.copyFileSync(sourcePath, destAbsPath);\n}\n","module.exports = require(\"fs\");","import {spawn} from 'child_process';\n\nimport {log} from './logger';\n\n// import {InterfaceCLI, getArgs} from './cli';\n// const patchExecutable = getArgs().patchExecutable;\n// const diffExecutable = getArgs().diffExecutable;\n\n// Returns patch between files as string\n// For our use case, the first path is the FB/base repo and the second path is the dirtry fork.\n// For files which doesn't exist in the FB/base repo, the path1IsNew should be set so that we create path for 'new file'\n// Return empty string when files are identical\nexport function diffFiles(\n  path1: string,\n  path1IsNew: boolean /* TODO :: path2IsNew ? */,\n  path2: string,\n  callback: (diff: string) => void,\n  errorcallback: (error: string) => void,\n  diffExecutable: string,\n) {\n  const diffArgs = [path1, path2, '-u' /*-U 3*/];\n  if (path1IsNew) diffArgs.push('--unidirectional-new-file');\n\n  const diff = spawn(diffExecutable, diffArgs);\n\n  diff.stdout.on('data', (data: string) => {\n    callback(data);\n  });\n\n  diff.stderr.on('data', (data: any) => {\n    errorcallback(`${diffExecutable} ${diffArgs} failed with message: ${data}`);\n  });\n\n  diff.on('close', (code: any) => {\n    log.verbose('Patch', `git child process exited with code ${code}`);\n  });\n}\n\nexport function applyPatch(\n  targetPath: string,\n  patchPath: string,\n  callback: (result: string) => void,\n  errorcallback: (error: string) => void,\n  patchExecutable: string,\n  reverse: boolean,\n) {\n  const patchArgs = ['-i', patchPath, targetPath, '-s'];\n  if (reverse) {\n    patchArgs.push('-R');\n  }\n\n  const patch = spawn(patchExecutable, patchArgs);\n  log.info(\n    'Patch',\n    'Calling C:\\\\Program Files\\\\Git\\\\usr\\\\bin\\\\patch.exe ' +\n      patchArgs.toString(),\n  );\n\n  patch.on('message', (message: string) => {\n    callback(`Patch message: ${message}`);\n  });\n\n  patch.stdout.on('data', (data: string) => {\n    callback(`Patch output: ${data}`);\n  });\n\n  patch.stderr.on('data', (data: any) => {\n    errorcallback(\n      `${patchExecutable} ${patchArgs} failed with message: ${data}`,\n    );\n  });\n\n  patch.on('close', (code: any) => {\n    log.info('Patch', `patch child process exited with code ${code}`);\n  });\n}\n","module.exports = require(\"child_process\");","import {isTextSync, isBinarySync} from 'istextorbinary';\n\nexport function isFileText(filepath: string) {\n  return isTextSync(filepath);\n}\n\nexport function isFileBinary(filepath: string) {\n  return isBinarySync(filepath);\n}\n","import diffRepos from './diffRepos';\nimport patchRepo from './patchRepo';\nimport {initCli} from './cli';\n\ninitCli(diffRepos, patchRepo);\n","import {\n  traverseDirectory,\n  writeFile,\n  getRelativePath,\n  lookUpRelativePath,\n  initDirectory,\n  resolvePath,\n  copyFile2,\n  getFileNameExtension,\n} from './fs_utils';\nimport {diffFiles} from './patch_utils';\nimport {log} from './logger';\nimport {isFileText, isFileBinary} from './file_type_utils';\nimport {compareFiles} from './file_compare';\nimport {cleanRepoSync} from './git_utils';\n\nimport {IDiffCommandOptions, DiffReposFuncType} from './types';\n\nconst diffRepos: DiffReposFuncType = (\n  dirtyRepoAbsPath: string,\n  baseRepoAbsPath: string,\n  options: IDiffCommandOptions,\n) => {\n  log.info('diffRepos', `dirtyRepoAbsPath: ${dirtyRepoAbsPath}`);\n  log.info('diffRepos', `baseRepoAbsPath: ${baseRepoAbsPath}`);\n  log.info('diffRepos', `options.patchName: ${options.patchName}`);\n  log.info('diffRepos', `options.whitelistDirs: ${options.whitelistDirs}`);\n  log.info('diffRepos', `options.blacklistDirs: ${options.blacklistDirs}`);\n  log.info('diffRepos', `options.blacklistExts: ${options.blacklistExts}`);\n  log.info('diffRepos', `options.gitExecutable: ${options.gitExecutable}`);\n  log.info('diffRepos', `options.cleanupRepos: ${options.cleanupRepos}`);\n\n  log.info('diffRepos', `options.diffExecutable: ${options.diffExecutable}`);\n  log.info(\n    'diffRepos',\n    `options.cleanupExistingPatches: ${options.cleanupExistingPatches}`,\n  );\n\n  const patchStorePath = resolvePath(dirtyRepoAbsPath, options.patchName);\n\n  // Where we write the patches ..\n  // const bothPath = resolvePath(patchStorePath, 'both');\n  // const forkOnlyPath = resolvePath(patchStorePath, 'fork-only');\n\n  // Init output directory\n  // initDirectory(bothPath);\n  // initDirectory(forkOnlyPath);\n  initDirectory(patchStorePath);\n\n  if (options.cleanupRepos) {\n    cleanRepoSync(options.baseFork, options.gitExecutable);\n    cleanRepoSync(options.dirtyFork, options.gitExecutable);\n  }\n\n  const callbackFile = (dirtyRepoFileAbsPath: string) => {\n    const forkFileRelativePath = getRelativePath(\n      dirtyRepoFileAbsPath,\n      dirtyRepoAbsPath,\n    );\n\n    const fileNameExtension = getFileNameExtension(dirtyRepoFileAbsPath);\n    if (options.blacklistExts.includes(fileNameExtension)) {\n      log.info(\n        'diffRNFork',\n        `Ignoring {dirtyRepoFileAbsPath} based on file name extension.`,\n      );\n      return;\n    }\n    const callbackOnHit = (fbRepoFileAbsPath: string) => {\n      const callbackOnDiffCreated = (patch: string) => {\n        writeFile(patchStorePath, forkFileRelativePath, `${patch}`, '');\n      };\n      const callbackOnError = (error: string) => {\n        log.error('diffRNFork', error);\n      };\n      const callbackOnBinaryFilesCompare = (same: boolean) => {\n        if (!same) {\n          copyFile2(patchStorePath, forkFileRelativePath, dirtyRepoFileAbsPath);\n        } else {\n          log.info(\n            'diffRNFork',\n            `Skip copying identical binary files: ${forkFileRelativePath}`,\n          );\n        }\n      };\n      const callbackOnBinaryFilesCompareError = (result: string) => {\n        log.error('diffRNFork', `callbackOnBinaryFilesCompareError: ${result}`);\n      };\n\n      const handleBinaryFileInFork = () => {\n        compareFiles(\n          fbRepoFileAbsPath,\n          dirtyRepoFileAbsPath,\n          callbackOnBinaryFilesCompare,\n          callbackOnBinaryFilesCompareError,\n        );\n      };\n      // If it's a binary file we copy it as is to the patches folder.\n      if (isFileBinary(dirtyRepoFileAbsPath)) {\n        handleBinaryFileInFork();\n      } else {\n        diffFiles(\n          fbRepoFileAbsPath,\n          false /* new file*/,\n          dirtyRepoFileAbsPath,\n          callbackOnDiffCreated,\n          callbackOnError,\n          options.diffExecutable,\n        );\n      }\n    };\n\n    const callbackOnMiss = (fbRepoFileAbsPath: string) => {\n      const callbackOnDiffCreated = (patch: string) => {\n        writeFile(patchStorePath, forkFileRelativePath, `${patch}`, '');\n      };\n      const callbackOnError = (error: string) => {\n        log.error('diffRNFork', error);\n      };\n      const handleBinaryFileInFork = () => {\n        copyFile2(patchStorePath, forkFileRelativePath, dirtyRepoFileAbsPath);\n      };\n      if (isFileBinary(dirtyRepoFileAbsPath)) {\n        handleBinaryFileInFork();\n      } else {\n        diffFiles(\n          fbRepoFileAbsPath,\n          true /* new file*/,\n          dirtyRepoFileAbsPath,\n          callbackOnDiffCreated,\n          callbackOnError,\n          options.diffExecutable,\n        );\n      }\n    };\n\n    lookUpRelativePath(\n      baseRepoAbsPath,\n      forkFileRelativePath,\n      callbackOnHit,\n      callbackOnMiss,\n    );\n  };\n\n  const callbackDirectory = (path: string) => {};\n\n  /*\n  Pseudo-code\n  1. Traverse through the fork rep\n  2. For each file look for the same file in the base repo\n  3. If the file is found in the base repo, then create and write the patch file to the patches directory , keeping the same directory hierarchy.\n  4. If the file is not found in the base repo, then also create and write the patch file in the patch directory, keeping the same directory hierarchy.\n  5. If the file is a binary file, we don't try to diff it, instead just copy the binary file to that patch directory.\n\n  Please note that we currently don't traverse the base reporitory, assuming that all the files in the base repository are present in the fork also. Essentially, we expect the patches to be only additions.\n  */\n\n  if (options.whitelistDirs.length === 0) {\n    traverseDirectory(\n      dirtyRepoAbsPath,\n      '.',\n      callbackFile,\n      callbackDirectory,\n      options.blacklistDirs,\n    );\n  } else {\n    options.whitelistDirs.forEach(dir => {\n      if (\n        options.blacklistDirs.includes(\n          dir.startsWith('.\\\\') ? dir.substr(2) : dir,\n        )\n      ) {\n        log.info(\n          'diffRNFork',\n          `${dir} is present in both whitelist as well as blacklist. Ignoring it.`,\n        );\n      } else {\n        traverseDirectory(\n          dirtyRepoAbsPath,\n          dir,\n          callbackFile,\n          callbackDirectory,\n          options.blacklistDirs,\n        );\n      }\n    });\n  }\n};\n\nexport default diffRepos;\n","module.exports = require(\"fs-extra\");","module.exports = require(\"path\");","module.exports = require(\"winston\");","module.exports = require(\"istextorbinary\");","import fse from 'fs';\nimport crypto from 'crypto';\n\nimport {log} from './logger';\n\nexport function compareFiles(\n  path1: string,\n  path2: string,\n  callback: (result: boolean) => void,\n  callbackOnError: (result: string) => void,\n) {\n  try {\n    const hash1 = crypto.createHash('md5');\n    const stream1 = fse.createReadStream(path1);\n\n    stream1.on('data', data => {\n      hash1.update(data);\n    });\n\n    stream1.on('end', () => {\n      const hash1Digest = hash1.digest('base64');\n\n      const hash2 = crypto.createHash('md5');\n      const stream2 = fse.createReadStream(path2);\n\n      stream2.on('data', data => {\n        hash2.update(data);\n      });\n\n      stream2.on('end', () => {\n        const hash2Digest = hash2.digest('base64');\n\n        if (hash1Digest === hash2Digest) {\n          log.info(\n            'compareFiles',\n            `${path1} AND ${path2} are identical.  hashes: ${hash1Digest} <==> ${hash2Digest}`,\n          );\n          callback(true);\n        } else {\n          log.info(\n            'compareFiles',\n            `${path1} AND ${path2} are different. hashes: ${hash1Digest} <==> ${hash2Digest}`,\n          );\n          callback(false);\n        }\n      });\n    });\n  } catch (e) {\n    callbackOnError(`${e}`);\n  }\n}\n","module.exports = require(\"crypto\");","import {spawn, spawnSync} from 'child_process';\nimport {log} from './logger';\n\nexport function cleanRepoSync(path: string, gitExecutable: string) {\n  const gitArgs = ['clean', '-fdx'];\n  const gitClean = spawnSync(gitExecutable, gitArgs, {cwd: path});\n  if (gitClean.error) {\n    log.error('cleanRepoSync', `Failed with error : ${gitClean.error}`);\n  }\n}\n","import {\n  traverseDirectory,\n  writeFile,\n  getRelativePath,\n  lookUpRelativePath,\n  initDirectory,\n  resolvePath,\n  copyFile,\n  copyFileOverwrite,\n  copyFile2Overwrite,\n} from './fs_utils';\nimport {log} from './logger';\nimport {applyPatch} from './patch_utils';\nimport {isFileText, isFileBinary} from './file_type_utils';\nimport {IPatchCommandOptions, PatchRepoFuncType} from './types';\n\nconst patchRepo: PatchRepoFuncType = (\n  targetRepoAbsPath: string,\n  patchNames: string[],\n  options: IPatchCommandOptions,\n) => {\n  log.info('patchRepo', `targetRepoAbsPath: ${targetRepoAbsPath}`);\n  log.info('patchRepo', `patchNames: ${patchNames}`);\n  log.info('patchRepo', `options.patchStore: ${options.patchStore}`);\n  log.info('patchRepo', `options.reverse: ${options.reverse}`);\n  log.info('patchRepo', `options.patchExecutable: ${options.patchExecutable}`);\n\n  log.info('patchRepo', `options.gitExecutable: ${options.gitExecutable}`);\n  log.info('patchRepo', `options.cleanupRepos: ${options.cleanupRepos}`);\n\n  const callbackFile = (\n    patchFileAbsPath: string,\n    patchFileRootAbsPath: string,\n  ) => {\n    const patchFileRelativePath = getRelativePath(\n      patchFileAbsPath,\n      patchFileRootAbsPath,\n    );\n\n    const callbackOnHit = (hitPatchFileAbsPath: string) => {\n      if (!isFileBinary(patchFileAbsPath)) {\n        applyPatch(\n          hitPatchFileAbsPath,\n          patchFileAbsPath,\n          (result: string) => {\n            log.info('PatchRNFork', result);\n          },\n          (result: string) => {\n            log.error('PatchRNFork', result);\n          },\n          options.patchExecutable,\n          options.reverse,\n        );\n      } else {\n        // Overwrite the file.\n        copyFileOverwrite(patchFileAbsPath, hitPatchFileAbsPath);\n      }\n    };\n\n    const callbackOnMiss = (missedPatchFileAbsPath: string) => {\n      log.error(\n        'PatchRNFork',\n        `File path with patches (${missedPatchFileAbsPath}) not found in the target repository.`,\n      );\n\n      if (isFileBinary(patchFileAbsPath)) {\n        // If patch file is binary, we copy anyways.\n        copyFile(patchFileAbsPath, missedPatchFileAbsPath);\n      } else {\n        applyPatch(\n          missedPatchFileAbsPath,\n          patchFileAbsPath,\n          (result: string) => {\n            log.info('PatchRNFork', result);\n          },\n          (result: string) => {\n            log.error('PatchRNFork', result);\n          },\n          options.patchExecutable,\n          options.reverse,\n        );\n      }\n    };\n\n    lookUpRelativePath(\n      targetRepoAbsPath,\n      patchFileRelativePath,\n      callbackOnHit,\n      callbackOnMiss,\n    );\n  };\n\n  const callbackDirectory = (path: string, rootAbsPath: string) => {\n    // tslint:disable-next-line:no-console\n    // console.log('Directory: ' + path);\n  };\n\n  patchNames.forEach(patchName => {\n    const patchNameDirAbsPath = resolvePath(options.patchStore, patchName);\n    traverseDirectory(\n      patchNameDirAbsPath,\n      '.',\n      callbackFile,\n      callbackDirectory,\n      [],\n    );\n  });\n};\n\nexport default patchRepo;\n","import program from 'commander';\nimport {log} from './logger';\nimport fse from 'fs-extra';\n\nimport {DiffReposFuncType, PatchRepoFuncType} from './types';\n\nprogram.version('0.0.1');\n\nexport function initCli(\n  diffReposFunc: DiffReposFuncType,\n  patchRepoFunc: PatchRepoFuncType,\n) {\n  const defaultWhiteListDirs: string[] = [];\n\n  const defaultBlackListExts = ['.iml'];\n\n  // Places we don't want to look for changes\n  const defaultBlackListDirs = [\n    '.ado',\n    '.appveyor',\n    '.circleci',\n    '.editorconfig',\n    '.eslintignore',\n    '.eslintrc',\n    '.flowconfig',\n    '.flowconfig.android',\n    '.flowconfig.macos',\n    '.git',\n    '.gitattributes',\n    '.github',\n    '.github.flowconfig.android',\n    '.gitignore',\n    '.nvmrc',\n    '.prettierrc',\n    'bots',\n    'Brewfile',\n    //'build.gradle', //'CHANGELOG.json', //'CHANGELOG.md', //'cli.js', //'CODE_OF_CONDUCT.md', //'ContainerShip', //'CONTRIBUTING.md',\n    'danger',\n    'double-conversion',\n    //'ECOSYSTEM.md',\n    'flow',\n    'flow-typed',\n    'Folly',\n    'follybuild',\n    'glog',\n    '.gradle',\n    //'gradle', //'gradlew', //'gradlew.bat', //'IntegrationTests',\n    '.idea',\n    'jest',\n    'jest-preset.js',\n    'jest.config.js',\n    'jsc',\n    //'KeepingRecent.md',\n    'keystores',\n    'lib',\n    //'Libraries', //'LICENSE', //'LICENSE-docs', //'local-cli',\n    'metadata',\n    //'metro.config.js',\n    'office-android-patches',\n    //'package.json',\n    'packages',\n    //'processor',\n    'React',\n    //'react-native.config.js', //'react.gradle',\n    'React.podspec',\n    //'ReactAndroid',\n    'ReactApple',\n    //'ReactCommon', //'README.md', //'Releases.md', //'rn-get-polyfills.js', //'RNTester',\n    'runXcodeTests.sh',\n    //'scripts', //'settings.gradle.kts',\n    'stubs',\n    //'template', //'template.config.js',\n    'third-party-podspecs',\n    //'tools',\n    'v8-docker-build',\n    'website',\n    'yarn.lock',\n    'android',\n    'node_modules',\n    'ReactAndroid\\\\build',\n    'ReactAndroid\\\\packages',\n    'RNTester\\\\android\\\\app\\\\build',\n    'processor\\\\build',\n    'local.properties',\n  ];\n\n  function commaSeparatedList(value: string, dummyPrevious: any) {\n    return value.split(',');\n  }\n\n  program\n    .command('diff <dirtyRepo> <baseRepo>')\n    .description('Diff create ..')\n    .option(\n      '-pf, --patch-name <path>',\n      'Name of the patch folder. This new folder will be created under the dirty repo',\n      'patches',\n    )\n    .option(\n      '-de, --diff-executable <path>',\n      'Full path of the diff utility to be used for diffing between files. What we expect is a *x diff utility or compatible one: http://man7.org/linux/man-pages/man1/diff.1.html',\n      'C:\\\\Program Files\\\\Git\\\\usr\\\\bin\\\\diff.exe',\n    )\n    .option(\n      '-ge, --git-executable <path>',\n      'Full path of the git executable',\n      'C:\\\\Program Files\\\\Git\\\\bin\\\\git.exe',\n    )\n    .option(\n      '-cc, --cleanup-repos',\n      \"Whether to clean up both the dirty and base repos. It will cleanup all non-tracked files. Essentially we run 'git clean -fdx'\",\n      false,\n    )\n    .option(\n      '-cp, --cleanup-existing-patches',\n      'Cleanup the existing patches in the patches folder before starting a new diff run',\n      true,\n    )\n    .option(\n      '-bl, --blacklist-dirs <paths>',\n      'Paths in dirty repo to be excluded from the patch creation and application',\n      commaSeparatedList,\n      defaultBlackListDirs,\n    )\n    .option(\n      '-be, --blacklist-exts <exts>',\n      'File name extensions in dirty repo to be excluded from the patch creation and application',\n      commaSeparatedList,\n      defaultBlackListExts,\n    )\n    .option(\n      '-wl, --whitelist-dirs <paths>',\n      'Paths in dirty repo to be included in the patch creation and application',\n      commaSeparatedList,\n      defaultWhiteListDirs,\n    )\n    .action((dirtyRepo: string, baseRepo: string, cmdObject: any) => {\n      diffReposFunc(dirtyRepo, baseRepo, cmdObject);\n    });\n\n  program\n    .command('patch <targetRepo> [patchNames...]')\n    .option(\n      '-ps, --patch-store <path>',\n      'Full path of the directory where the patches can be found. Each patch is a subdirectory in this directory.',\n      'E:\\\\github\\\\office-android-patches\\\\patches-droid-office-grouped',\n    )\n    .option(\n      '-pe, --patch-executable <path>',\n      'Full path of the patch utility to be used for patching. What we expect is a *x patch utility or compatible one: http://man7.org/linux/man-pages/man1/patch.1.html',\n      'C:\\\\Program Files\\\\Git\\\\usr\\\\bin\\\\patch.exe',\n    )\n    .option('-r, --reverse', 'Whether the patch is applied reverse', false)\n    .option(\n      '-ge, --git-executable <path>',\n      'Full path of the git executable',\n      'C:\\\\Program Files\\\\Git\\\\bin\\\\git.exe',\n    )\n    .option(\n      '-cc, --cleanup-repos',\n      \"Whether to clean up both the dirty and base repos. It will cleanup all non-tracked files. Essentially we run 'git clean -fdx'\",\n      false,\n    )\n    .action((targetRepo: string, patchNames: string[], cmdObject: any) => {\n      patchRepoFunc(targetRepo, patchNames, cmdObject);\n    });\n\n  program.parse(process.argv);\n\n  function logErrorAndExitApp(message: string) {\n    log.error('cli', message);\n    process.exit(1);\n  }\n\n  // if (!cli.applyPatch && !cli.createPatch) {\n  //   logErrorAndExitApp(\n  //     'Either createPath or applyPatch option should be specified when launching the application.',\n  //   );\n  // }\n\n  // if (cli.applyPatch) {\n  //   if (!cli.targetFork) {\n  //     logErrorAndExitApp('Target fork path is required for applying patch.');\n  //   }\n  //   if (!fse.existsSync(cli.targetFork)) {\n  //     logErrorAndExitApp(\n  //       `Target fork path (${cli.targetFork}) must exist for applying patch.`,\n  //     );\n  //   }\n  //   if (!cli.patchFolder) {\n  //     logErrorAndExitApp('Patch folder is required for applying patch.');\n  //   }\n  //   if (!fse.existsSync(cli.patchFolder)) {\n  //     logErrorAndExitApp(\n  //       `Patch folder (${cli.patchFolder}) must exist for applying patch.`,\n  //     );\n  //   }\n  //   if (!cli.patchExecutable) {\n  //     logErrorAndExitApp(\n  //       'Patch executable path is required for applying patch.',\n  //     );\n  //   }\n  //   if (!fse.existsSync(cli.patchExecutable)) {\n  //     logErrorAndExitApp(\n  //       `Patch executable path (${cli.patchExecutable}) must exist for applying patch.`,\n  //     );\n  //   }\n  // }\n\n  // if (cli.createPatch) {\n  //   if (!cli.dirtyFork) {\n  //     logErrorAndExitApp('Dirty fork path is required for creating patch.');\n  //   }\n  //   if (!fse.existsSync(cli.dirtyFork)) {\n  //     logErrorAndExitApp(\n  //       `Dirty fork path (${cli.dirtyFork}) must exist for creating patch.`,\n  //     );\n  //   }\n  //   if (!cli.baseFork) {\n  //     logErrorAndExitApp('Base fork path is required for creating patch.');\n  //   }\n  //   if (!fse.existsSync(cli.baseFork)) {\n  //     logErrorAndExitApp(\n  //       `Base fork path (${cli.baseFork}) must exist for creating patch.`,\n  //     );\n  //   }\n  //   if (!cli.diffExecutable) {\n  //     logErrorAndExitApp(\n  //       'Diff executable path is required for creating patch.',\n  //     );\n  //   }\n  //   if (!fse.existsSync(cli.diffExecutable)) {\n  //     logErrorAndExitApp(\n  //       `Diff executable path (${cli.diffExecutable}) must exist for creating patch.`,\n  //     );\n  //   }\n  // }\n\n  // log.info('Main', `cli.dirtyFork: ${cli.dirtyFork}`);\n  // log.info('Main', `cli.baseFork: ${cli.baseFork}`);\n  // log.info('Main', `cli.targetFork: ${cli.targetFork}`);\n  // log.info('Main', `cli.patchFolder: ${cli.patchFolder}`);\n  // log.info('Main', `cli.applyPatch: ${cli.applyPatch}`);\n  // log.info('Main', `cli.createPatch: ${cli.createPatch}`);\n  // log.info('Main', `cli.patchExecutable: ${cli.patchExecutable}`);\n  // log.info('Main', `cli.diffExecutable: ${cli.diffExecutable}`);\n  // log.info('Main', `cli.gitExecutable: ${cli.gitExecutable}`);\n  // log.info('Main', `cli.cleanupForks: ${cli.cleanupForks}`);\n  // log.info('Main', `cli.cleanupExistingPatches: ${cli.cleanupExistingPatches}`);\n  // log.info('Main', `cli.blacklistDirs: ${cli.blacklistDirs}`);\n  // log.info('Main', `cli.whitelistDirs: ${cli.whitelistDirs}`);\n\n  // export function getArgs(): InterfaceCLI {\n  //   return cli;\n  // }\n}\n","module.exports = require(\"commander\");"],"sourceRoot":""}